{"meta":{"title":"MicDZ's blog","subtitle":null,"description":null,"author":"MicDZ","url":"https://www.micdz.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"2021-02-27T11:38:38.446Z","updated":"2021-02-27T11:38:38.446Z","comments":true,"path":"404.html","permalink":"https://www.micdz.cn/404.html","excerpt":"","text":"很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2021-02-27T11:38:38.466Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"about/index.html","permalink":"https://www.micdz.cn/about/index.html","excerpt":"","text":"MicDZ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Life is short, AC more ~ 我是一名在读中学生，现就读于长沙市长郡中学，是漫威粉和米粉。 欢迎留言～"},{"title":"所有分类","date":"2021-02-27T11:38:38.466Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"categories/index.html","permalink":"https://www.micdz.cn/categories/index.html","excerpt":"","text":""},{"title":"嫦娥为什么不需要暴击陨石技能","date":"2021-02-27T11:38:38.466Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"change/index.html","permalink":"https://www.micdz.cn/change/index.html","excerpt":"","text":""},{"title":"404 Not Found","date":"2021-02-27T11:38:38.466Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"count/index.html","permalink":"https://www.micdz.cn/count/index.html","excerpt":"","text":"目前距离2022年湖南省高考还有 221 天 11 时 37 分 32 秒 function getRTime(){ var EndTime= new Date('2022/06/08 09:00:00'); //截止时间 var NowTime = new Date(); var t =EndTime.getTime() - NowTime.getTime(); var d=Math.floor(t/1000/60/60/24); var h=Math.floor(t/1000/60/60%24); var m=Math.floor(t/1000/60%60); var s=Math.floor(t/1000%60); document.getElementById(\"t_d\").innerHTML = d + \" 天\"; document.getElementById(\"t_h\").innerHTML = h + \" 时\"; document.getElementById(\"t_m\").innerHTML = m + \" 分\"; document.getElementById(\"t_s\").innerHTML = s + \" 秒\"; } setInterval(getRTime,1000);"},{"title":"Friends","date":"2021-02-27T11:38:38.534Z","updated":"2021-02-27T11:38:38.534Z","comments":true,"path":"friends/index.html","permalink":"https://www.micdz.cn/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话，请先添加我的友链后，在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： MicDZ’s blog 头像： https://www.micdz.cn/img/h.png 网址： https://www.micdz.cn/ 标签：OIER"},{"title":"","date":"2021-02-27T11:38:38.586Z","updated":"2021-02-27T11:38:38.586Z","comments":true,"path":"js/ui.js","permalink":"https://www.micdz.cn/js/ui.js","excerpt":"","text":"var mizhu = new function() { var ww = window.innerWidth if (ww < 768) { this.width = $(window).width() * 0.8; this.height = 172; } else { this.width = $(window).width() * 0.5; this.height = 172; } this.close = function() { $('.win iframe').fadeOut(); $('.win').fadeOut(\"fast\"); setTimeout(function() { $('.win iframe').remove(); $('.win').remove(); }, 200); }; this.open = function(width, height, title, url, closed) { this._close = function() { this.close(); if($.isFunction(closed)) closed(); }; var html = '×'; var jq = $(html); jq.find(\".window-panel\").height(mizhu.height).width(mizhu.width).css(\"margin-left\", -mizhu.width / 2).css(\"margin-top\", -mizhu.height); jq.find(\".title\").find(\":header\").html(title); jq.find(\".body-panel\").height(height - 36).attr(\"src\", url); jq.appendTo('body').fadeIn(\"fast\"); $(\".win .window-panel\").focus(); }; function messageBox(html, title, message, type) { var jq = $(html); if(type == \"toast\") { jq.find(\".window-panel\").width(message.length * 20).css(\"margin-left\", -message.length * 20 / 2).css(\"margin-top\", -mizhu.height / 2); } else { jq.find(\".window-panel\").width(mizhu.width).css(\"margin-left\", -mizhu.width / 2).css(\"margin-top\", -mizhu.height / 2 - 36); } if(valempty(title)) { jq.find(\".title\").remove(); jq.find(\".window-panel .body-panel\").css(\"border-radius\", \"4px\"); } else { jq.find(\".title\").find(\":header\").html(title); } jq.find(\".content\").html(message.replace('\\r\\n', '')); jq.appendTo('body').fadeIn(\"fast\"); $(\".win .w-btn:first\").focus(); } this.confirm = function(title, message, selected) { this._close = function(flag) { if(flag) { $(\".win\").remove(); selected(flag); } else { this.close(); }; }; var html = '取消确定'; messageBox(html, title, message); }; this.alert = function(title, message, ico) { var icon = \"\"; if(!valempty(ico)) { icon = ''; } var html = '' + icon + '确定'; messageBox(html, title, message); } this.toast = function(message, time) { var html = ''; messageBox(html, \"\", message, \"toast\"); setTimeout(function() { mizhu.close(); }, time || 3000); } }; function valempty(str) { if(str == \"null\" || str == null || str == \"\" || str == \"undefined\" || str == undefined || str == 0) { return true; } else { return false; } }"},{"title":"","date":"2021-02-27T11:38:38.586Z","updated":"2021-02-27T11:38:38.586Z","comments":true,"path":"projects/index.html","permalink":"https://www.micdz.cn/projects/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-02-27T11:38:38.586Z","updated":"2021-02-27T11:38:38.586Z","comments":true,"path":"tags/index.html","permalink":"https://www.micdz.cn/tags/index.html","excerpt":"","text":""},{"title":"2022高考倒计时","date":"2019-09-13T10:54:35.000Z","updated":"2021-02-27T11:38:38.586Z","comments":false,"path":"time/index.html","permalink":"https://www.micdz.cn/time/index.html","excerpt":"","text":""}],"posts":[{"title":"配子一定比例致死的人类遗传病计算问题","slug":"thoughts-of-a-biological-problem","date":"2021-02-04T18:41:20.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/thoughts-of-a-biological-problem/","link":"","permalink":"https://www.micdz.cn/article/thoughts-of-a-biological-problem/","excerpt":"半年没更博，文化课战士回来报道。","text":"半年没更博，文化课战士回来报道。 前言 老师同学们好！ 本人高中生，有关生物的见识仅局限高中范围，本文有关专有用语可能不够准确。本文旨在分享我对此前期考复习前的一道题目的思考。 题目内容如下： 右图是甲、乙两种单基因遗传病的家系图，家系中无突变发生且其中一种病为伴X遗传。已知正常人群中乙病携带者占1/6，且含乙病基因的雄配子半数致死。6号个体与人群中正常男性结婚，生育一个两病兼患男孩的概率是( )。A. 1/184 B. 1/192 C. 1/368 D. 1/384 这道题的最初来源我没有能够找到，只在[1]中有所发现。 问题分析 甲病有关基因用 XAX^AXA 与 XaX^aXa 表示，乙病有关基因用 BBB 与 bbb 表示。对于甲病的结果我不存在质疑，很容易得出该夫妇生出一个患甲病男孩的概率 P1=12×12×14=116P_1=\\frac{1}{2}\\times\\frac{1}{2}\\times\\frac{1}{4}=\\frac{1}{16} P1​=21​×21​×41​=161​ 接下来仅需计算该夫妇所生育的孩子中患乙病的概率 P2P_2P2​，通过自由组合定律即可得出该题的答案 P=P1×P2P=P_1\\times P_2 P=P1​×P2​ 问题的焦点在于如何计算 P2P_2P2​ 。 计算机模拟结果 将原问题抽离成为与现实相符的一个模型。假设现有一个大小为 NNN 的男性正常群体。 我将男性每一个个体从 111 至 NNN 编号记为 ai=ia_i=iai​=i 。为了满足题目条件，另 ∀ai≡1(mod6)\\forall a_i\\equiv 1 \\pmod{6}∀ai​≡1(mod6) 的男性个体为乙病的携带者。 然后随机生成一个数 x∈[1,N]x\\in [1,N]x∈[1,N] 表示个体6与编号为 xxx 的男性个体交配。 如果 x≡1(mod6)x\\equiv 1 \\pmod{6}x≡1(mod6) 则表示个体6与一男性乙病的携带者交配。考虑该男性的配子。若不考虑致死该男性配子 BBB 与 bbb 应为 1:11:11:1 。现 bbb 半数致死，则该男性配子比例应为 2:12:12:1 。因而再生成一个随机数 y∈[1,3]y\\in[1,3]y∈[1,3] ，如果所得随机数为 111 则此次模拟该男性产生的配子为 bbb ，其余情况则为 BBB 。 如果 xxx 不满足 x≡1(mod6)x\\equiv 1 \\pmod{6}x≡1(mod6) 。则该男性产生的配子一定为 BBB。 将男性产生的配子与女性的配子组合即可得到后代的基因型。 将随机生成 xxx 的步骤重复 Ω\\OmegaΩ 次，记录下其中后代为 bbbbbb 的次数 TTT 即可得到 P2=TΩP_2=\\frac{T}{\\Omega} P2​=ΩT​ 计算机实现代码如下： c++代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=1000000+10;const int N=1000000;int a[MAXN];int _rand(int l,int r) &#123; return rand()%(r-l+1)+l;&#125;int main() &#123; freopen(&quot;data.out&quot;,&quot;w&quot;,stdout); srand(time(0)); printf(&quot;%d\\n&quot;,_rand(1,2)); const int omega=1000000; int T=0; for(int i=1; i&lt;=omega; i++) &#123; int x=_rand(1,N); if(x%6==1) &#123; int y=_rand(1,3); if(y==1) &#123;T++; printf(&quot;x:%d y:%d T+1\\n&quot;,x,y); &#125; else printf(&quot;x:%d y:%d T+0\\n&quot;,x,y); &#125; else printf(&quot;x:%d\\n&quot;,x); &#125; printf(&quot;Ω:%d T:%d\\n&quot;,omega,T); return 0;&#125; python代码 1234567891011121314151617181920212223import randomT=0Omega=1000000N=1000000fp=open(&quot;./data.txt&quot;,&quot;w+&quot;)for i in range(1,Omega): x=random.randint(1,N) if(x%6==1): y=random.randint(1,3) if(y==1): T+=1 print(&quot;x:&quot;,x,&quot; y:&quot;,y,&quot; T+1&quot;,file=fp) else: print(&quot;x:&quot;,x,&quot; y:&quot;,y,&quot; T+0&quot;,file=fp) else: print(&quot;x:&quot;,x,file=fp)print(&quot;Ω:&quot;,Omega,&quot; T:&quot;,T,file=fp)fp.close() 计算机模拟的结果如下： 单机此处下载 /data.txt 最终 Ω=1000000\\Omega=1000000Ω=1000000 T=55506T=55506T=55506。 P2=TΩ=555061000000=0.055506≈118P_2=\\frac{T}{\\Omega}=\\frac{55506}{1000000}=0.055506\\approx\\frac{1}{18} P2​=ΩT​=100000055506​=0.055506≈181​ 参考答案的计算方式 我在这里简单描述一下参考答案的计算方式。 对于一个人群，其中有 16\\frac{1}{6}61​ 的正常男性，则可知男性中 BB:Bb=5:1BB:Bb=5:1BB:Bb=5:1 。假设不考虑考虑男性配子致死的情况，则该人群中正常男性产生的配子比例 B:b=11:1B:b=11:1B:b=11:1 。又由于有一半的 bbb 致死，则比例为 B:b=11:0.5=22:1B:b=11:0.5=22:1B:b=11:0.5=22:1 。则男性群体中产生 bbb 配子的概率为 P2=123P_2=\\frac{1}{23}P2​=231​ 。这样得出的答案 P=P1×P2=116×123=1368P=P_1\\times P_2=\\frac{1}{16}\\times\\frac{1}{23}=\\frac{1}{368} P=P1​×P2​=161​×231​=3681​ 应选C。 然而，这样计算得来的 P2P_2P2​ 与计算机模拟的结果不同。 我认为的计算方式 对于个体6，记她所遇到的男性个体为乙病携带者的事件为 SSS ，所遇到不为乙病携带者的事件为 TTT 。显然 P(S)=16P(S)=\\frac{1}{6}P(S)=61​ ， P(T)=56P(T)=\\frac{5}{6}P(T)=65​ 。 将正常男性群体产生的配子分为两类，一类为纯合子产生的配子 B1B_1B1​ ，另一类为杂合子产生的配子 B2B_2B2​ 与 b2b_2b2​ 。 然后再考虑个体6所遇的配子的问题。记个体6的配子 bbb 与 b2b_2b2​ 相遇的事件为 YYY 。 显然 P2=P(SY)=P(S)×P(Y∣S)=16×13=118P_2=P(SY)=P(S)\\times P(Y|S)=\\frac{1}{6}\\times\\frac{1}{3}=\\frac{1}{18} P2​=P(SY)=P(S)×P(Y∣S)=61​×31​=181​ 简单来说，就是个体6有 16\\frac{1}{6}61​ 的可能与一名携带乙病基因的男性交配，而与一名携带乙病基因的男性交配后代为乙病的概率为 13\\frac{1}{3}31​ ，因而个体6与人群中正常男性交配后代患乙病的概率 P2=13×16P_2=\\frac{1}{3}\\times\\frac{1}{6}P2​=31​×61​ 。 两种计算方式答案不同的分析 参考答案错误的可能原因 对于参考答案的计算方式，我们可以理解为，将人群中所有正常男性的配子放在一起，再从这些配子中随机选取一个。这样可以解释为什么分母为 232323 。 这样对于存在致死的男性的配子，他们的配子在整个男性人群中则会少去致死的那一部分，使存在致死男性的竞争力减弱。 简单来说，例如这里有 121212 名男性，其中 101010 人为 BBBBBB ， 222 人为 BbBbBb 。假设每个人产生两个配子。一共会产生 12×2−1=2312\\times2-1=2312×2−1=23 个配子。则产生配子的比例为 B1:B2:b2=20:2:1B_1:B_2:b_2=20:2:1B1​:B2​:b2​=20:2:1 。如果直接从这 232323 个配子中计算比例，那么对于 BbBbBb 男性人群与个体6交配的概率为 B2+b2B1+B2+b2=1+323&lt;16\\frac{B_2+b_2}{B_1+B_2+b_2}=\\frac{1+3}{23}&lt;\\frac{1}{6}B1​+B2​+b2​B2​+b2​​=231+3​&lt;61​ 。这与事实是矛盾。 事实情况应保证个体6与任意男性交配的概率相当，即个体6与 BbBbBb 男性群体交配的比例应当为 16\\frac{1}{6}61​ 。解决这一问题就需要分步进行讨论。 两种计算方式的适用性 如果对于人类群体而言，我认为，应当使用后面的计算方式。 如果对象是花粉传播的植物，若假设所有不携带乙病基因的雄性植株个体产生的花粉数相同，而携带乙病基因的雄性植株产生的花粉少 14\\frac{1}{4}41​ ，那么携带乙病基因的植株竞争力会减弱，则应当使用参考答案的方式。 我的态度 以下为我的态度，可能存在事实性错误。我认为参考答案的计算方法不符合实际，应为答案错误。对于这样一个实际问题，不存在两种答案，更不存在一种更精确一种高级的说法，一定存在唯一正确的答案。对于是否“超纲”的问题，我尚不清楚，但可以肯定的是往年高考出现过配子致死的题目。 恳请老师同学对我的想法批评指导。与我联系me@micdz.cn。 参考资料 [1]. 2020学年第一学期浙南名校联盟第一次联考高三年级生物试题卷 鸣谢 感谢邓毅萍老师。 感谢许锜桐同学。","categories":[{"name":"Others","slug":"Others","permalink":"https://www.micdz.cn/categories/Others/"}],"tags":[{"name":"生物","slug":"生物","permalink":"https://www.micdz.cn/tags/%E7%94%9F%E7%89%A9/"}]},{"title":"windows10的Ubuntu子系统","slug":"windows10-ubuntu20","date":"2020-05-10T18:53:13.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/windows10-ubuntu20/","link":"","permalink":"https://www.micdz.cn/article/windows10-ubuntu20/","excerpt":"在win10上运行最新的Ubuntu终端。","text":"在win10上运行最新的Ubuntu终端。 很早时候windows就发布了其可以在win10运行的Ubuntu子系统。 总的来说这个子系统与一个普通的Ubuntu没有区别。 这里总结一下子系统一些目录在win10的对应关系。 目录对应关系 根目录 \\ 根目录对应在 C:\\Users\\[WIN_USER]\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu[UBUNTU_RELEASES]onWindows_79rhkp1fndgsc\\LocalState\\rootfs 其中 [WIN_USER] 表示你的windows系统用户名， [UBUNTU_RELEASES] 表示你安装的Ubuntu版本号， [UBUNTU_USER] 表示你在子系统下的用户名。 home目录 ~ home目录对应在 C:\\Users\\[WIN_USER]\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu[UBUNTU_RELEASES]onWindows_79rhkp1fndgsc\\LocalState\\rootfs\\home\\[UBUNTU_USER] 启动默认目录 /mnt/c/Users/MicDZ 对应为 C:\\Users\\[WIN_USER] 操作 与普通Ubuntu无异。","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.micdz.cn/tags/ubuntu/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://www.micdz.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"【51nod2014】小朋友的笑话 题解","slug":"51nod2014-solution","date":"2020-04-04T15:24:47.000Z","updated":"2021-02-27T11:38:38.462Z","comments":true,"path":"article/51nod2014-solution/","link":"","permalink":"https://www.micdz.cn/article/51nod2014-solution/","excerpt":"51nod2014","text":"51nod2014 核心思路 解决这道题需要面对两个问题。首先是如何求或修改某一区间的小朋友的状态，这可以用线段树解决；其次是如何知道某一个（段）小朋友已经听过这个笑话，这个问题可以用 max⁡{l}\\max\\{l\\}max{l} 个set维护。 具体的操作是这样。首先得到了一段 [x−k,x+k][x-k,x+k][x−k,x+k] 的区间，将这个区间内的所有数修改为 111，再将这个区间与对应笑话的set取并，将交集部分修改为 000 。取交集的操作是，先找到第一个包含于 [x−k,x+k][x-k,x+k][x−k,x+k] 的区间，然后向后增加指针直至离开 [x−k,x+k][x-k,x+k][x−k,x+k] 这一区间。 set中最多出现 nnn 个区间，查找到第一个需要 nlog⁡nn\\log nnlogn ，从那往后最多经历 nnn 个区间，修改每一个区间的复杂度为 log⁡n\\log nlogn，因此总的复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn) 。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;set&gt;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int n,m;namespace Brute &#123; const int MAXN=1e4+10; bool mark[MAXN][MAXN],sta[MAXN]; void main() &#123; REP(i,1,m) &#123; int op=read(); if(op==1) &#123; int x=read(),l=read(),k=read(); REP(j,max(1,x-k),min(n,x+k)) &#123; if(mark[j][l]) sta[j]=0; else sta[j]=1; mark[j][l]=1; &#125; &#125; else &#123; int l=read(),r=read(),ans=0; REP(j,l,r) ans+=sta[j]; printf(&quot;%d\\n&quot;,ans); &#125; &#125; &#125;&#125;namespace AC &#123; const int MAXN=1e5+10; set&lt;pair&lt;int,int&gt; &gt; s[MAXN]; struct SegmentTree &#123; int lf[MAXN&lt;&lt;2],rg[MAXN&lt;&lt;2],add[MAXN&lt;&lt;2],sum[MAXN&lt;&lt;2],a[MAXN&lt;&lt;2];#define l(x) lf[x]#define r(x) rg[x]#define len(x) (rg[x]-lf[x]+1) void pushup(int p) &#123;sum[p]=sum[p*2]+sum[p*2+1];&#125; void pushdown(int p) &#123; if(add[p]!=-1) &#123; add[p*2]=add[p]; add[p*2+1]=add[p]; sum[p*2]=add[p]*len(p*2); sum[p*2+1]=add[p]*len(p*2+1); add[p]=-1; &#125; &#125; void build(int p,int l,int r) &#123; l(p)=l,r(p)=r; if(l==r) &#123;sum[p]=0,add[p]=-1;return ;&#125; int mid=(l+r)&gt;&gt;1; build(p*2,l,mid); build(p*2+1,mid+1,r); pushup(p); &#125; void change(int p,int l,int r,int d) &#123; if(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123; sum[p]=d*len(p); add[p]=d; return ; &#125; pushdown(p); int mid=(l(p)+r(p))&gt;&gt;1; if(l&lt;=mid) change(p*2,l,r,d); if(r&gt;mid) change(p*2+1,l,r,d); pushup(p); &#125; int ask(int p,int l,int r) &#123; if(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) return sum[p]; int ans=0; pushdown(p); int mid=(l(p)+r(p))&gt;&gt;1; if(l&lt;=mid) ans+=ask(p*2,l,r); if(r&gt;mid) ans+=ask(p*2+1,l,r); return ans; &#125; &#125; seg;#define mp(a,b) make_pair(a,b) void main() &#123; seg.build(1,1,n); REP(i,1,m) &#123; int op=read(); if(op==1) &#123; int x=read(),L=read(),k=read(),l=max(1,x-k),r=min(n,x+k),nowl=l,nowr=r; if(s[L].size()) &#123; set&lt;pair&lt;int,int&gt; &gt;::iterator it=s[L].lower_bound(mp(l,0)); set&lt;pair&lt;int,int&gt; &gt;::iterator pre=it; if(it!=s[L].begin()) &#123; pre--; if((*pre).second&gt;=l) it=pre; &#125; if(it==s[L].end()||(*it).first&gt;r) &#123; s[L].insert(mp(l,r)); seg.change(1,l,r,1); &#125; else &#123; nowl=min(nowl,(*it).first);seg.change(1,l,r,1); seg.change(1,l,r,1); while(it!=s[L].end()&amp;&amp;(*it).first&lt;=r) &#123; seg.change(1,max(l,(*it).first),min(r,(*it).second),0); nowr=max(nowr,(*it).second); pre=it,it++;s[L].erase(pre); &#125; s[L].insert(mp(nowl,nowr)); &#125; &#125; else &#123; seg.change(1,l,r,1); s[L].insert(mp(l,r)); &#125; &#125; else &#123; int l=read(),r=read(); printf(&quot;%d\\n&quot;,seg.ask(1,l,r)); &#125; &#125; &#125;&#125;int main() &#123; n=read(),m=read(); AC::main(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"【51nod1444】破坏道路 题解","slug":"51nod1444-solution","date":"2020-03-29T16:06:54.000Z","updated":"2021-02-27T11:38:38.462Z","comments":true,"path":"article/51nod1444-solution/","link":"","permalink":"https://www.micdz.cn/article/51nod1444-solution/","excerpt":"51nod1444","text":"51nod1444 核心思路 相当简单的一道题，只要把所有的方案枚举出来找到最优的即可。 枚举的过程很有规律，可以利用位运算降低代码的复杂度。 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=3000+10,MAXM=MAXN*MAXN;int head[MAXN],_next[MAXM],to[MAXM],cnt;void addedge(int u,int v) &#123; cnt++; _next[cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125;int dis[MAXN][MAXN];queue&lt;int&gt; q;void bfs(int s) &#123; dis[s][s]=0; q.push(s); while(!q.empty()) &#123; int u=q.front();q.pop(); for(int i=head[u]; i; i=_next[i]) &#123; int v=to[i]; if(dis[s][v]==dis[s][0]) dis[s][v]=dis[s][u]+1,q.push(v); &#125; &#125;&#125;int main() &#123; int n=read(),m=read(); REP(i,1,m) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; memset(dis,127,sizeof(dis)); REP(i,1,n) bfs(i); //REP(i,1,n)&#123; REP(j,1,n) printf(&quot;%d &quot;,dis[i][j]); puts(&quot;&quot;);&#125; int s[2][2],l[2]; s[0][0]=read(),s[0][1]=read(),l[0]=read(),s[1][0]=read(),s[1][1]=read(),l[1]=read(); REP(i,0,1) if(dis[s[i][0]][s[i][1]]&gt;l[i]) &#123; puts(&quot;-1&quot;); return 0; &#125; int ans=m; REP(i,0,1) ans-=dis[s[i][0]][s[i][1]]; REP(i,1,n) REP(j,1,n) &#123; REP(k,0,1) REP(p,0,1) &#123; int dis1=dis[s[0][0^p]][i]+dis[i][j]+dis[j][s[0][1^p]]; int dis2=dis[s[1][0^k]][i]+dis[i][j]+dis[j][s[1][1^k]]; if(dis1&lt;=l[0]&amp;&amp;dis2&lt;=l[1]) ans=max(ans,m-(dis1+dis2-dis[i][j])); &#125; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://www.micdz.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"【51nod1331】狭窄的通道 题解","slug":"51nod1331-solution","date":"2020-03-29T14:58:11.000Z","updated":"2021-02-27T11:38:38.462Z","comments":true,"path":"article/51nod1331-solution/","link":"","permalink":"https://www.micdz.cn/article/51nod1331-solution/","excerpt":"51nod1331","text":"51nod1331 核心思路 这道题有一些细节需要注意。 分为两类情况，一类是中间有一些不去两头将交换的，另一类是所有的都交换。有一些狼可以左右两个交换区都经过。然后还有一堆非常难调的细节，考场上没能写出来。 复杂度为 O(n3)O(n^3)O(n3) 。 完整代码 参考这位博主。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=50+10,INF=0x3f3f3f3f;struct edge &#123; int s,t;&#125; a[MAXN];bool cmp1(edge a,edge b) &#123; return a.s&lt;b.s;&#125;bool cmp2(edge a,edge b) &#123; return a.t&lt;b.t;&#125;int n,l,ans;void calc(int pos) &#123; sort(a+1,a+pos+1,cmp2); sort(a+pos+1,a+n+1,cmp2); int leng=0; REP(i,1,pos) leng+=a[i].s+a[i].t; REP(i,pos+1,n) leng+=l-a[i].s+l-a[i].t; int sum1=0,sum2=0; REP(i,pos+1,n) &#123; sum1=0; REP(j,1,pos) if(a[j].t&gt;=a[i].t) sum1+=2*(l-a[j].t); ans=min(ans,leng+sum1+sum2); sum2+=2*a[i].t; &#125;&#125;bool pd(int l,int r,int _l,int _r) &#123; int n1=0,n2=INF; REP(i,l,r) n1=max(n1,a[i].t); REP(i,_l,_r) n2=min(n2,a[i].t); return n1&lt;n2;&#125;int main() &#123; int t=read(); while(t--) &#123; ans=INF; n=read(),l=read(); REP(i,1,n) a[i]=(edge)&#123;read(),read()&#125;; REP(i,0,n) &#123; sort(a+1,a+1+n,cmp1); calc(i); &#125; sort(a+1,a+1+n,cmp1); int si=0; REP(i,0,n) &#123; si+=a[i].t+a[i].s; if(pd(1,i,i+1,n)) &#123; int j=i+1,tot=0; for(; j&lt;=n; j++) if(!pd(i+1,j,j+1,n)) &#123;break;&#125; // DE(&quot;%d\\n&quot;,j); REP(k,i+1,j-1) tot+=abs(a[k].t-a[k].s); REP(k,j,n) tot+=l-a[k].s+l-a[k].t; ans=min(ans,si+tot); &#125; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"【51nod1564】区间的价值 题解","slug":"51nod1564-solution","date":"2020-03-29T14:22:04.000Z","updated":"2021-02-27T11:38:38.462Z","comments":true,"path":"article/51nod1564-solution/","link":"","permalink":"https://www.micdz.cn/article/51nod1564-solution/","excerpt":"51nod1564","text":"51nod1564 核心思路 这道题是“细节理解题”，题目的关键在于“ aia_iai​ 的值将会是 1−1091-10^91−109内随机的一个数”。这保证了没有特殊构造的数据来卡我特定的算法。 可以尺取来更新答案，我们要使得最小值最大。所以每次只需要将 l−1l-1l−1 和 r+1r+1r+1 中较小的那一个加入即可。每次加入后更新答案。 没有特殊构造数据，期望复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。特殊构造可以卡至 O(n2)O(n^2)O(n2) 。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;#define ll long long#define int llint read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=100000+10,INF=0x3f3f3f3f;int a[MAXN];namespace Solution &#123; int ans[MAXN]; //stack&lt;pair&lt;int,int&gt; &gt; s; void main() &#123; int n=read(); REP(i,1,n) a[i]=read(); REP(i,1,n) &#123; ans[1]=max(ans[1],1ll*a[i]*a[i]); int minn=a[i],maxx=a[i],l=i,r=i; while(a[l]&lt;=maxx&amp;&amp;a[r]&lt;=maxx) &#123; if(a[l-1]&gt;a[r+1]) l--; else r++; if(r&gt;n) r--; if(l&lt;1) l++; minn=min(minn,min(a[l],a[r])); ans[r-l+1]=max(ans[r-l+1],1ll*maxx*minn); if(l==1&amp;&amp;r==n) break; &#125; &#125; REP(i,1,n) printf(&quot;%lld\\n&quot;,ans[i]); &#125;&#125;signed main() &#123; Solution::main(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Hello, word!","slug":"Hello-World","date":"2020-02-23T18:30:39.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/Hello-World/","link":"","permalink":"https://www.micdz.cn/article/Hello-World/","excerpt":"欢迎来到MicDZ’s blog。","text":"欢迎来到MicDZ’s blog。 如果您觉得博客中有任何问题，希望您提出宝贵的意见。","categories":[{"name":"Others","slug":"Others","permalink":"https://www.micdz.cn/categories/Others/"}],"tags":[]},{"title":"【JSOI2013】侦探jyy 题解","slug":"JSOI2013-zhentanjyy-solution","date":"2020-02-03T09:35:43.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/JSOI2013-zhentanjyy-solution/","link":"","permalink":"https://www.micdz.cn/article/JSOI2013-zhentanjyy-solution/","excerpt":"JSOI2013","text":"JSOI2013 核心思路 我们枚举每一个点，假设这个点不发生，那么它的前驱都不能发生。搜索完它的全部前驱打上标记作为这些点不能发生。然后再从剩下不一定发生的点中贪心地将每一个入度为 000 的设定为一定发生，统计它们的全部后继，如果能够覆盖题目所给的 ddd 个点，那么最开始枚举的这个点就可以不发生，否则一定发生。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;#define REP(i,e,s) for(register int i=(e); i&lt;=(s); i++)#define DREP(i,e,s) for(register int i=(e); i&gt;=(s); i--)#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)#define ll long longint read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=1000+10,MAXM=100000+10;int head[MAXN],_next[MAXM],to[MAXM],cnt;void addedge(int u,int v) &#123; cnt++; _next[cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125;vector&lt;int&gt; g[MAXN];int book[MAXN],flag[MAXN],mark[MAXN];queue&lt;int&gt; q;void bfs(int s) &#123; q.push(s); while(!q.empty()) &#123; int u=q.front();q.pop(); REP(i,0,(int)g[u].size()-1) &#123; int v=g[u][i]; if(flag[v]) continue; flag[v]=1; q.push(v); &#125; &#125;&#125;int in[MAXN];void bfs2(int s) &#123; q.push(s);mark[s]=1; while(!q.empty()) &#123; int u=q.front();q.pop(); for(int i=head[u]; i; i=_next[i]) &#123; int v=to[i]; if(mark[v]) continue; mark[v]=1; q.push(v); &#125; &#125;&#125; int ans[MAXN];int main() &#123; int n=read(),m=read(),d=read(); REP(i,1,m) &#123; int u=read(),v=read(); addedge(u,v);in[v]++; g[v].push_back(u); &#125; REP(i,1,d) book[read()]=1; REP(i,1,n) &#123; memset(flag,0,sizeof(flag)); memset(mark,0,sizeof(flag)); bfs(i); REP(j,1,n) if(!flag[j]&amp;&amp;in[j]==0&amp;&amp;j!=i) bfs2(j); REP(j,1,n) &#123; if(!mark[j]&amp;&amp;book[j]) &#123; ans[i]=1; break; &#125; &#125; &#125; REP(i,1,n) if(ans[i]) printf(&quot;%d &quot;,i); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"贪心","slug":"贪心","permalink":"https://www.micdz.cn/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"【JSOI2011】棒棒糖 题解","slug":"JSOI2011-bangbangtang-solution","date":"2020-02-01T16:47:00.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/JSOI2011-bangbangtang-solution/","link":"","permalink":"https://www.micdz.cn/article/JSOI2011-bangbangtang-solution/","excerpt":"JSOI2011","text":"JSOI2011 核心思路 直接上一棵主席树，不用离散化美滋滋。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define REP(i,e,s) for(register int i=(e); i&lt;=(s); i++)#define DREP(i,e,s) for(register int i=(e); i&gt;=(s); i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=200000+10,MAXM=MAXN*18;;int rt[MAXM],a[MAXN];struct President_Tree &#123; int cnt,ls[MAXM],rs[MAXM],sum[MAXM]; President_Tree() &#123; cnt=0; &#125; void build(int &amp;p,int l,int r) &#123; p=++cnt; if(l==r) return ; int mid=(l+r)&gt;&gt;1; build(ls[p],l,mid); build(rs[p],mid+1,r); &#125; void change(int &amp;p,int l,int r,int u,int x) &#123; p=++cnt,ls[p]=ls[u],rs[p]=rs[u],sum[p]=sum[u]+1; if(l==r) return ; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) change(ls[p],l,mid,ls[u],x); else change(rs[p],mid+1,r,rs[u],x); &#125; int ask(int x,int y,int l,int r,int k) &#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1; if(sum[ls[y]]-sum[ls[x]]&gt;=k) return ask(ls[x],ls[y],l,mid,k); else if(sum[rs[y]]-sum[rs[x]]&gt;=k) return ask(rs[x],rs[y],mid+1,r,k); return -1; &#125;&#125; s;int main() &#123; int n=read(),m=read(); REP(i,1,n) a[i]=read(); int sz=n; s.build(rt[0],1,sz); REP(i,1,n) s.change(rt[i],1,sz,rt[i-1],a[i]); while(m--) &#123; int l=read(),r=read(); int t=s.ask(rt[l-1],rt[r],1,sz,(r-l+1)/2+1); if(t!=-1) printf(&quot;%d\\n&quot;,t); else puts(&quot;0&quot;); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"可持久化","slug":"可持久化","permalink":"https://www.micdz.cn/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"线段树","slug":"线段树","permalink":"https://www.micdz.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"可持久化线段树学习笔记","slug":"persistent-seg","date":"2020-01-19T16:19:03.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/persistent-seg/","link":"","permalink":"https://www.micdz.cn/article/persistent-seg/","excerpt":"主席树又称可持久化线段树","text":"主席树又称可持久化线段树 权值线段树 普通线段树的每一个节点表示区间，记录的是原序列在该区间上的一些信息。而权值线段树记录的是在整个序列中属于这个区间的元素的个数。 这样，在权值线段树中，元素与元素之间是无序的，类似与一棵平衡树。 下面是我用动态开点权值线段树写的普通平衡树。 其查询方式与BST类似。 权值线段树实现普通平衡树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define REP(i,e,s) for(register int i=(e); i&lt;=(s); i++)#define DREP(i,e,s) for(register int i=(e); i&gt;=(s); i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;#define int llconst int MAXN=100000+10;struct SegmentTree &#123; int lson[MAXN&lt;&lt;5],rson[MAXN&lt;&lt;5],a[MAXN]; int lf[MAXN&lt;&lt;5],rg[MAXN&lt;&lt;5],sum[MAXN&lt;&lt;5],add[MAXN&lt;&lt;5],cnt;#define l(x) lf[x]#define r(x) rg[x]#define sum(x) sum[x]#define add(x) add[x]#define len(x) (rg[x]-lf[x]+1) void pushup(int p) &#123; sum(p)=sum(lson[p])+sum(rson[p]); &#125; void pushdown(int p) &#123; if(add(p)) &#123; if(!lson[p]) lson[p]=++cnt; if(!rson[p]) rson[p]=++cnt; int mid=(l(p)+r(p))&gt;&gt;1; add(lson[p])=add(lson[p])+add(p); add(rson[p])=add(rson[p])+add(p); sum(lson[p])=sum(lson[p])+add(p)*(mid-l(p)+1); sum(rson[p])=sum(rson[p])+add(p)*(r(p)-mid); add(p)=0; &#125; &#125; void change(int &amp;p,int l,int r,int L,int R,int d) &#123; if(!p) p=++cnt,l(p)=l,r(p)=r; if(l(p)&gt;=L&amp;&amp;r(p)&lt;=R) &#123; sum(p)=sum(p)+d*len(p); add(p)=add(p)+d; return ; &#125; pushdown(p); int mid=(l(p)+r(p))&gt;&gt;1; if(L&lt;=mid) change(lson[p],l,mid,L,R,d); if(R&gt;mid) change(rson[p],mid+1,r,L,R,d); pushup(p); &#125; int ask(int p,int l,int r) &#123; if(!p) return 0; if(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) return sum(p); pushdown(p); int mid=(l(p)+r(p))&gt;&gt;1; int ans=0; if(l&lt;=mid) ans=ans+ask(lson[p],l,r); if(r&gt;mid) ans=ans+ask(rson[p],l,r); return ans; &#125; int getvl(int p,int l,int r,int rk) &#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1; if(sum(lson[p])&gt;=rk) return getvl(lson[p],l,mid,rk); else return getvl(rson[p],mid+1,r,rk-sum(lson[p])); &#125; int getrk(int p,int l,int r,int vl) &#123; if(!p) return 0; if(l==r) return 1; int mid=(l+r)&gt;&gt;1; if(vl&lt;=mid) return getrk(lson[p],l,mid,vl); else return sum[lson[p]]+getrk(rson[p],mid+1,r,vl); &#125;&#125; s;const int N=1e7+10;signed main() &#123; int n=read(),rt=0; REP(i,1,n) &#123; int op=read(); if(op==1) &#123; int x=read(); s.change(rt,-N,N,x,x,1); &#125; if(op==2) &#123; int x=read(); s.change(rt,-N,N,x,x,-1); &#125; if(op==3) &#123; int x=read(); printf(&quot;%lld\\n&quot;,s.getrk(1,-N,N,x)); &#125; if(op==4) &#123; int k=read(); printf(&quot;%lld\\n&quot;,s.getvl(1,-N,N,k)); &#125; if(op==5) &#123; int x=read(); printf(&quot;%lld\\n&quot;,s.getvl(1,-N,N,s.ask(1,-N,x-1))); &#125; if(op==6) &#123; int x=read(); printf(&quot;%lld\\n&quot;,s.getvl(1,-N,N,s.ask(1,-N,x)+1)); &#125; &#125; return 0;&#125; 权值线段树可以解决整个区间第 kkk 大的问题，那么如何动态查询区间第 kkk 大呢？权值线段树显然是无法完成的。 可持久化线段树 权值线段树支持查询区间 [1,n][1,n][1,n] 的第 kkk 大查询。 考虑解决查询 [l,r][l,r][l,r] 的第 kkk 大需要那些信息。与权值线段树类似的，我们只需要建立一棵 [l,r][l,r][l,r] 的权值线段树。 考虑如何快速地建立出这样的一棵权值线段树。 主席树就是解决这一问题的数据结构。 我们建立 nnn 棵权值线段树，第 iii 棵表示原序列 [1,i][1,i][1,i] 的权值线段树。当我们在查询 [l,r][l,r][l,r] 的时候即可通过 [1,r]−[1,l−1][1,r]-[1,l-1][1,r]−[1,l−1] 得到 [l,r][l,r][l,r] 的权值线段树。 为什么可以这么相减呢？假设现在我们要求解区间 [l,r][l,r][l,r]，我们已知 [1,l−1][1,l-1][1,l−1] 与 [1,r][1,r][1,r] 两棵权值线段树。假设有一个元素 aaa 在原序列中处于 [1,l−1][1,l-1][1,l−1] ，那么这一个节点不应被统计到答案中。我们再来看这个元素在两棵权值线段树中出现的位置，在第一棵权值线段树中所有包含于 {a}\\{a\\}{a} 的节点都会出现，在第二棵权值线段树中同样也是如此。因此，只要将两棵权值线段树前相同的部分相减即可得到 [l,r][l,r][l,r] 的权值线段树。 建树的过程也非常巧妙，我们可以发现所有与之前相同的节点在后续询问中永远不可能被访问，因此这一部分节点完全没有必要建立出来。可以参考下图。 【模板】可持久化线段树 1（主席树） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define REP(i,e,s) for(register int i=(e); i&lt;=(s); i++)#define DREP(i,e,s) for(register int i=(e); i&gt;=(s); i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=200000+10,MAXM=MAXN*18;;int rt[MAXM],a[MAXN],b[MAXN];struct Persistent_Tree &#123; int cnt,ls[MAXM],rs[MAXM],sum[MAXM]; Persistent_Tree() &#123; cnt=0; &#125; void build(int &amp;p,int l,int r) &#123; p=++cnt; if(l==r) return ; int mid=(l+r)&gt;&gt;1; build(ls[p],l,mid); build(rs[p],mid+1,r); &#125; void change(int &amp;p,int l,int r,int u,int x) &#123; p=++cnt,ls[p]=ls[u],rs[p]=rs[u],sum[p]=sum[u]+1; if(l==r) return ; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) change(ls[p],l,mid,ls[u],x); else change(rs[p],mid+1,r,rs[u],x); &#125; int ask(int x,int y,int l,int r,int k) &#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1; int v=sum[ls[y]]-sum[ls[x]]; if(v&gt;=k) return ask(ls[x],ls[y],l,mid,k); else return ask(rs[x],rs[y],mid+1,r,k-v); &#125;&#125; s;int main() &#123; int n=read(),m=read(); REP(i,1,n) a[i]=b[i]=read(); sort(b+1,b+1+n); int sz=unique(b+1,b+1+n)-b-1; s.build(rt[0],1,sz); REP(i,1,n) s.change(rt[i],1,sz,rt[i-1],lower_bound(b+1,b+sz+1,a[i])-b); while(m--) &#123; int l=read(),r=read(),k=read(); printf(&quot;%d\\n&quot;,b[s.ask(rt[l-1],rt[r],1,sz,k)]); &#125; return 0;&#125; 树上主席树 与主席树前缀和思想相似的，利用树上差分的情况也可以用主席树维护。 与序列不同的是，建树时是儿子节点与父亲节点不同的插入，查询时利用树上差分计算。 [SDOI2013]森林 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt; using namespace std; #define REP(i,e,s) for(register int i=(e); i&lt;=(s); i++)#define DREP(i,e,s) for(register int i=(e); i&gt;=(s); i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125; const int MAXN=80000+10,MAXM=MAXN*200; int rt[MAXM],a[MAXN],b[MAXN]; struct President_Tree &#123; int cnt,ls[MAXM],rs[MAXM],sum[MAXM]; void init() &#123; cnt=0; memset(ls,0,sizeof(ls)); memset(rs,0,sizeof(rs)); memset(sum,0,sizeof(sum)); &#125; void build(int &amp;p,int l,int r) &#123; p=++cnt; if(l==r) return ; int mid=(l+r)&gt;&gt;1; build(ls[p],l,mid); build(rs[p],mid+1,r); &#125; void change(int &amp;p,int l,int r,int u,int x) &#123; p=++cnt,ls[p]=ls[u],rs[p]=rs[u],sum[p]=sum[u]+1; if(l==r) return ; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) change(ls[p],l,mid,ls[u],x); else change(rs[p],mid+1,r,rs[u],x); &#125; int ask(int x,int y,int l,int r,int lc,int falc,int k) &#123; if(x==y) return x; int mid=(x+y)&gt;&gt;1; int v=sum[ls[l]]+sum[ls[r]]-sum[ls[lc]]-sum[ls[falc]]; if(v&gt;=k) return ask(x,mid,ls[l],ls[r],ls[lc],ls[falc],k); else return ask(mid+1,y,rs[l],rs[r],rs[lc],rs[falc],k-v); &#125;&#125; s; int head[MAXN],_next[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1],cnt; void addedge(int u,int v) &#123; cnt++; _next[cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125; int fa[MAXN][25],dist[MAXN]; queue&lt;int&gt; q; int sz; void bfs(int s) &#123; q.push(s); while(!q.empty()) &#123; int u=q.front();q.pop(); for(int i=head[u]; i; i=_next[i]) &#123; int v=to[i]; if(fa[u][0]==v) continue; fa[v][0]=u; dist[v]=dist[u]+1; q.push(v); &#125; &#125;&#125; int f[MAXN],son[MAXN],vis[MAXN]; int find(int x) &#123; if(f[x]==x) return x; return f[x]=find(f[x]);&#125; void dfs(int u,int p,int _rt) &#123; fa[u][0]=p; REP(i,1,19) fa[u][i]=fa[fa[u][i-1]][i-1]; son[_rt]++; dist[u]=dist[p]+1; f[u]=p; vis[u]=1; s.change(rt[u],1,sz,rt[p],a[u]); for(int i=head[u]; i; i=_next[i]) &#123; int v=to[i]; if(v==p) continue; dfs(v,u,_rt); &#125;&#125; int lca(int u,int v) &#123; if(dist[u]&lt;dist[v]) swap(u,v); int len=dist[u]-dist[v]; DREP(i,19,0) if(1&lt;&lt;i&amp;len) u=fa[u][i]; if(u==v) return u; DREP(i,19,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0];&#125; int last=0; void init() &#123; memset(head,0,sizeof(head)); memset(vis,0,sizeof(vis)); memset(fa,0,sizeof(fa)); memset(dist,0,sizeof(dist)); memset(son,0,sizeof(son)); memset(rt,0,sizeof(rt)); cnt=0;&#125; int main() &#123; read(); int n=read(),m=read(),q=read(); REP(i,1,n) a[i]=b[i]=read(),f[i]=i; sort(b+1,b+1+n); sz=unique(b+1,b+1+n)-b-1; s.build(rt[0],1,sz); REP(i,1,n) a[i]=lower_bound(b+1,b+1+sz,a[i])-b; REP(i,1,m) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; REP(i,1,n) &#123; if(!vis[i]) &#123; dfs(i,0,i); f[i]=i; &#125; &#125; int last=0; REP(i,1,q) &#123; char op[3]; scanf(&quot;%s&quot;,op+1); if(op[1]==&#x27;Q&#x27;) &#123; int u=read()^last,v=read()^last,k=read()^last,_lca=lca(u,v); last=b[s.ask(1,sz,rt[u],rt[v],rt[_lca],rt[fa[_lca][0]],k)]; printf(&quot;%d\\n&quot;,last); &#125; else &#123; int u=read()^last,v=read()^last,rtu=find(u),rtv=find(v); addedge(u,v);addedge(v,u); if(son[rtu]&lt;son[rtv]) swap(u,v),swap(rtu,rtv); dfs(v,u,rtu); &#125; &#125; return 0;&#125; 可修改主席树 咕咕咕","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"学习笔记","slug":"OI/学习笔记","permalink":"https://www.micdz.cn/categories/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"可持久化","slug":"可持久化","permalink":"https://www.micdz.cn/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"线段树","slug":"线段树","permalink":"https://www.micdz.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.micdz.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"2019回顾 & 2020展望","slug":"2020-resolution","date":"2020-01-01T00:00:01.000Z","updated":"2021-02-27T11:38:38.462Z","comments":true,"path":"article/2020-resolution/","link":"","permalink":"https://www.micdz.cn/article/2020-resolution/","excerpt":"语文不好，就当写篇作文练练笔吧","text":"语文不好，就当写篇作文练练笔吧 前言 岁月不居，时节如流。2019年很快过去了，回想一年前的此时，我还正深陷文化课的泥潭无法自拔，今年的我仍旧如此。 2019是不平凡的一年，这一年过得很充实、走得很坚定。 经历了中考，按国家的话来说，这是我们人生中第一场决定着未来命运的关键转折点；加入长郡信息组，虽然被大佬们吊打，但是收获颇丰；进入了1902班，交了太多朋友，一同见证了太多有意思的故事。 可能是在1902班时间不够长，不连续的缘故，现在听到“25班”，“电教委员”，我都还会条件反射。眼前闪过过去三年的点滴，浮起点点泪光。 感慨万千，乃提笔记之。 2019回顾 中考 2019年年初，是中考奋战的最后200天，抛开中考带来的紧迫感，学习之余有太多的乐趣可以追忆。诡计狗叫、猫狗联赛 [1]、国语近人 [2]、12.1事件 [3]、食堂事件 …… 但中考前有的不仅只是欢乐，还有考试失败的苦恼，来自同学、老师、家人的各种压力。 还记得年初的第一次月考，语文作文偏题的我获得了人生中第一个“C”，距离“D”线仅差1分，国家找我谈话，严厉地指出了我语文学习中的各种问题，那一刻，我认为我的初中语文学习是非常失败的，甚至丧失了考6A的信心。 颓废了一段时间，家人也十分担心，我的悲伤情绪无处排解，看番无动力，写作业没耐心，追美剧，嗯…没有这个条件。家中电脑被藏起，信息书被锁起。后来不知怎么的，有一天晚上，看到暴雨过后学校被淹没的草场，顶着严冬的冽风，突然间想明白了，必须要努力一把，否则自己是怎么失败的都不知道，但是找不到努力方向的我面对现实时，陷入无尽的茫然。 百日誓师，在初二生地会考百日誓师的前一天进行，多么希望时间能回到初二，再来一次生地会考。 后面的几次月考和全真模拟，包括和长郡系联考的月考，虽排名稍见起色，但是始终没能拿到全A，除了着急，也没有别的想法。 直到中考的前一天晚上，我的心里依旧没底，匆匆忙忙奔赴考场，匆匆忙忙写完试卷，乐呵乐呵老师考前押的题，中考就迷迷糊糊考完了。考场上、考后的记忆全部丢失，回忆不起什么来了。 成绩揭晓，事实证明，我是幸运的，广益是幸运的。 中考前的挫折，中考时的沉着，让我看到了自己尚存希望，未来可期。 初至郡园 早已做好了长郡小的心理准备，但还是没想到长郡会这么小，原以为操场后面一排贴了运动标志的建筑也是长郡教学楼，原以为体育馆后面还有一半只是平常未开放，原以为一教一层有三间教室。 起初是没有想法高中就读长郡的，来考理实也是抱着碰碰运气的想法。但是，当我慢慢了解这个学校，我就慢慢地理解了她的包容、朴实、严谨。这些正是我所向往的。 从附中系初中毕业到长郡是不容易的，在这过程中我要非常感谢国家、砣哥耐心的帮助我分析选择，在我做出选择后坚定不移地支持我。最终这个选择也没有让我后悔。 总之，在长郡的生活仿佛就是一个人生的新开始，新的同学，新的校园文化，新的老师都让我兴奋无比。 长郡信息组 很感谢遇见了tham，tham是我所有教练中最负责、最有耐心、最和同学相处融洽的教练。至今还记得在云机房，tham讲一道题，讲着讲着就策不清了，借口出去打电话，打了一个小时电话后回来继续策。讲到最后我们也是云里雾里，这样的情况下tham竟重头再讲了一遍（虽然第二遍讲完听懂的人没有变多）。 机房的巨佬就不一一列举了，伤心。。 虽然CSP2019没有取得期望的成绩 [4]，但是它暴露了许多此前我不曾发现的问题，这些问题在过去的每一场考试中都有出现但都没有引起重视。 2020展望 祖国富强 2020决胜全面建成小康社会，再奋斗15年基本实现现代化。感谢祖国给我们带来的生活上实实在在的改善。 文化课程 应当摒弃此前的不切实际吃老本的幻想，一定要扎扎实实做好作业，实时跟踪复习，独立完成每一道习题才会在考试的时候不会有这样或那样的失误。 竞赛课程 保持一定的刷题时间，学习一些新的知识。千万记住，一定要培养自己独立解题的能力，没事多做点codeforces、atcoder的比赛。及时总结所学。 后记 感谢过去一年中陪伴我的老师、同学、好伙伴，祝各位在新的一年中实现理想，学业有成，工作顺利！ 2019年，充实度过，但是，也留下了一些遗憾。虽付出努力，但未能获得自己想要的成果。这固然是对自己预期过高、实力不够的必然结果，但是2020年，我不会允许这样的错误再次发生，希望自己无悔付出！ 希望明年在写下2021年展望时可以想起现在立的flag。 多年以后再回头看看这篇文章应该会是非常愉快的事情。 引用 [1]. 猫狗联赛 C1625班级内部联赛，分为狗队和猫队。由于狗队（其实是我）发动迁移球员运动，狗队集中了一大批有着充足精力和爆发力的球员，故除了第一赛季猫队获得冠军外，第二、三、四赛季狗队以不败战绩连续卫冕。 [2]. 国语近人（一个咕咕的项目） [3]. 关于将12.1设立为“放火纪念日”的通告 关于将12.1设立为“放火纪念日”的通告 2018年的12月1日8:55分左右，老针、周君等一众革命志士，在中栋五楼废弃办公室旁点燃了饮水机，吹响了反国运动的冲锋号，并在国家、严志等人的严刑逼供下拒不招认，把血液里的党性保留到了生命的最后一刻，两人于当天下午在蔡毅的办公室里英勇就义。 但烈士的鲜血不会白流！经中诡中央主要领导人lyz、mj、qy（钱勇）等人研究决定，将12.1设立为“放火纪念日”，以此激励广大中诡党员干部砥砺奋进，在各自的岗位上大有作为！ 中诡中央党总支 2019年11月30日 [4]. 由于一些特殊情况，踩线2=.","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[]},{"title":"【tyvj1061】Mobile Service 题解","slug":"tyvj1061-solution","date":"2019-12-10T12:48:18.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/tyvj1061-solution/","link":"","permalink":"https://www.micdz.cn/article/tyvj1061-solution/","excerpt":"tyvj1061","text":"tyvj1061 核心思路 首先可以直接思考到的是设 fi,a,b,cf_{i,a,b,c}fi,a,b,c​ 表示，进行到第 iii 个任务时，三个服务员分别在 a,b,ca,b,ca,b,c 的最小花费。 这个的复杂度为 O(NL3)O(NL^3)O(NL3) ，显然过不了。 然后就是比较套路的步骤了。发现记录的三个位置并不是都会用到，因为在完成了第 iii 个任务后，必定有一个服务员在 PiP_iPi​，这样就可以优化到 O(NL2)O(NL^2)O(NL2) 了。 然后发现卡空间，滚动数组优化下就可以了。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define REP(i,e,s) for(register int i=(e); i&lt;=(s); i++)#define DREP(i,e,s) for(register int i=(e); i&gt;=(s); i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=1000+1,MAXL=200+1,INF=0x3f3f3f3f;int c[MAXL][MAXL],p[MAXN],f[2][MAXL][MAXL];int main() &#123; int l=read(),n=read(); REP(i,1,l) REP(j,1,l) c[i][j]=read(); REP(i,1,n) p[i]=read(); int o=0; memset(f[o],127,sizeof(f[o])); p[0]=3; f[0][1][2]=0; REP(i,0,n) &#123; o^=1; memset(f[o],127,sizeof(f[o])); REP(x,1,l) REP(y,1,l) &#123; f[o][x][y]=min(f[o][x][y],f[o^1][x][y]+c[p[i]][p[i+1]]); f[o][p[i]][y]=min(f[o][p[i]][y],f[o^1][x][y]+c[x][p[i+1]]); f[o][x][p[i]]=min(f[o][x][p[i]],f[o^1][x][y]+c[y][p[i+1]]); &#125; &#125; int ans=INF; REP(i,1,l) REP(j,1,l) &#123; if(i==j) continue; ans=min(ans,f[o][i][j]); &#125; DE(&quot;%.2f MB\\n&quot;,(sizeof(c)+sizeof(p)+sizeof(f))*1.0/1048576); printf(&quot;%d\\n&quot;,ans); return 0; &#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.micdz.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"每周学习总结","slug":"weekly","date":"2019-11-30T12:45:46.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/weekly/","link":"","permalink":"https://www.micdz.cn/article/weekly/","excerpt":"每周学习总结","text":"每周学习总结 2019.11.30-2019.12.6 准备月考 思考了CSP2019没有做出来的题目 学习了换根DP，还未完成POJ3585，准备重写 2019.12.7-2019.12.13 进行《进阶指南》上的DP练习 来源 题目名称 大致思路 解题报告 POJ3585 Accumulation Degree 换根DP 无 HDU2196 Computer 换根DP，相对模板 无 IOI1999 花店橱窗布置 线性DP，注意下边界 无 TYVJ1061 Mobile Service 线性DP，滚动数组优化空间 链接 POJ1821 Fence 单调队列优化DP，注意边界 无 2019.12.14-2019.12.20 来源 题目名称 大致思路 解题报告 CF915F Imbalance Value of a Tree 图论，技巧 无 HNOI2012 矿场搭建 图论，割点 无","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://www.micdz.cn/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"【POI2017】flappybird 题解","slug":"POI2017-flappybird-solution","date":"2019-11-08T12:45:00.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/POI2017-flappybird-solution/","link":"","permalink":"https://www.micdz.cn/article/POI2017-flappybird-solution/","excerpt":"POI","text":"POI 核心思路 乍一看，这道题像是NOIP的flappybird的加强版。然而，认真分析一下好像任何dp都不能解决这道题。 那么考虑一下题目有什么特殊性质： 不能多次点击 每一次要么加一，要么减一 考虑直接模拟小鸟飞行的过程。 从第 iii 个障碍物到第 i+1i+1i+1 个障碍物，小鸟飞行的区间： {max⁡i=min⁡{max⁡i−1+xi−xi−1,highi}min⁡i=max⁡{min⁡i−1−(xi−xi−1),lowi)}\\begin{cases} \\max_i=\\min\\{\\max_{i-1}+x_i-x_{i-1},\\mathrm{high}_i\\}\\\\ \\min_i=\\max\\{\\min_{i-1}-(x_i-x_{i-1}),\\mathrm{low}_i)\\} \\end{cases} {maxi​=min{maxi−1​+xi​−xi−1​,highi​}mini​=max{mini−1​−(xi​−xi−1​),lowi​)}​ 推完之后你会发现，小鸟并不能出现在这个区间的每一个位置上，因为点一次与不点产生的差距为 222 ，即你无法改变最终到达位置的奇偶性。那么再判一下奇偶性即可。 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=5e5+10,INF=0x3f3f3f;int x[MAXN],low[MAXN],up[MAXN];int main() &#123; int n=read(),X=read(); REP(i,1,n) x[i]=read(),low[i]=read(),up[i]=read(); int a=0,b=0; REP(i,1,n) &#123; a=min(a+(x[i]-x[i-1]),up[i]-1); b=max(b-(x[i]-x[i-1]),low[i]+1); if((a&amp;1)!=(x[i]&amp;1)) a--; if((b&amp;1)!=(x[i]&amp;1)) b++; if(a&lt;b) &#123; puts(&quot;NIE&quot;); return 0; &#125; &#125; printf(&quot;%d\\n&quot;,(x[n]+b)/2); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"贪心","slug":"贪心","permalink":"https://www.micdz.cn/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"【NOIP2015】运输计划 题解","slug":"NOIP2015-yunshujihua-solution","date":"2019-11-07T23:26:55.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/NOIP2015-yunshujihua-solution/","link":"","permalink":"https://www.micdz.cn/article/NOIP2015-yunshujihua-solution/","excerpt":"NOIP2015","text":"NOIP2015 std1 std3","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"LCA","slug":"LCA","permalink":"https://www.micdz.cn/tags/LCA/"}]},{"title":"【nowcoder-1103A】复读数组 题解","slug":"nowcoder-1103A-solution","date":"2019-11-06T23:07:21.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/nowcoder-1103A-solution/","link":"","permalink":"https://www.micdz.cn/article/nowcoder-1103A-solution/","excerpt":"nowcoder-1103 CSP-S提高组赛前集训营4 A题","text":"nowcoder-1103 CSP-S提高组赛前集训营4 A题 刚拿到题就觉得比较神仙，又因为之前做过一道长得很像但几乎没什么关系的神仙题更加深了这种感觉。 看左右两位神仙半小时就交了一发还写了拍，我才刚读完题，感觉这场凉凉，结果还真凉了。 题目大意 给定长为 nnn 的数列 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​ ，将这个数列循环 kkk 次。求 ∑1≤i≤j≤n×k∣⋃k=ij{ak}∣\\sum_{1\\leq i\\leq j\\leq n\\times k}\\left| \\bigcup_{k=i}^j\\{a_k\\}\\right| 1≤i≤j≤n×k∑​∣∣∣∣∣​k=i⋃j​{ak​}∣∣∣∣∣​ 的值 mod 109+7\\bmod 10^9+7mod109+7 。 核心思路 首先想想可不可以写一个 O(nk)O(nk)O(nk) 的暴力，设 fif_ifi​ 为以 iii 为右端点区间的贡献。 这个式子一开始分类讨论要死。写了几十行还一直WA，调自闭后，冷静分析一下，好像是一个傻逼转移。 设 preipre_iprei​ 为最后一个与 aia_iai​ 相同点的编号。转移如下： fi=fi−1+i−preif_i=f_{i-1}+i-pre_i fi​=fi−1​+i−prei​ 这样你就获得了70pts的好成绩。 这时离下考差不多只有1.5h了，我决定继续刚这题。 直接推式子，……，经过一番努力，你发现式子并不好推，但是把一些因数提出来之后貌似有等差数列的性质。 于是愉快地开始打表，打出每 kkk 个的 fif_ifi​ 之和，发现从第三项开始即为等差数列。 然后用高斯求和公式就愉快地解决了。 代码还是有些小细节。 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt; using namespace std;#define int ll#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout) int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125; const ll MOD=1e9+7,MAXN=6e5+10;int a[MAXN],b[MAXN],pos[MAXN],pre[MAXN],f[MAXN]; int qpow(int a) &#123; int ans=1,b=MOD-2; while(b) &#123; if(b&amp;1) ans=ans*a%MOD; a=a*a%MOD; b&gt;&gt;=1; &#125; return ans;&#125; int sum[4]; signed main() &#123; int n=read(),k=read(); REP(i,1,n) b[i]=a[i]=read(); sort(b+1,b+1+n); int num=unique(b+1,b+1+n)-b-1; REP(i,1,n) a[i]=lower_bound(b+1,b+1+num,a[i])-b; REP(i,n+1,3*n) a[i]=a[i-n]; REP(i,1,3*n) pre[i]=pos[a[i]],pos[a[i]]=i; REP(i,1,3*n) f[i]=f[i-1]+i-pre[i]; REP(i,1,3) &#123; sum[i]=0; REP(j,1+(i-1)*n,i*n) sum[i]=(sum[i]+f[j])%MOD; &#125;//直接找出前3n个的每一节答案 int ans=(sum[1]+(2*sum[2]%MOD+(sum[3]-sum[2]+MOD)%MOD*(k+MOD-2)%MOD)%MOD*(k+MOD-1)%MOD*qpow(2))%MOD; //从第二节开始为等差数列 printf(&quot;%lld\\n&quot;,ans%MOD); return 0;&#125;//考场代码略丑，轻D","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【JXOI2018】游戏 题解","slug":"JXOI2018-youxi-solution","date":"2019-11-03T22:55:49.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/JXOI2018-youxi-solution/","link":"","permalink":"https://www.micdz.cn/article/JXOI2018-youxi-solution/","excerpt":"JXOI2018","text":"JXOI2018 数学专题都好神仙啊 这道题神奇的有两个题面。 核心思路 我们把 [l,r][l, r][l,r] 内不是其它任何数的倍数的数称为关键数，那么 t(p)t(p)t(p) 显然等于该排列中最后一个关键点的位置。 设 numnumnum 为 [l,r][l,r][l,r] 中关键点的个数，那么枚举最后一个关键点的位置，答案就很显然了 ∑i=1ni×(i−1)!×num×(n−sn−i)×(n−i)!\\sum_{i=1}^ni\\times(i-1)!\\times num \\times{n-s\\choose n-i}\\times(n-i)! i=1∑n​i×(i−1)!×num×(n−in−s​)×(n−i)! 稍微解释一下， iii 后面位置是不能再放关键点的，因此有 (n−sn−i)n-s\\choose n-i(n−in−s​) 种选法。 iii 位置必须为关键点，因此有 numnumnum 种选法， iii 前与 iii 后随便选取，那么有 (i−1)!×(n−i)!(i-1)!\\times(n-i)!(i−1)!×(n−i)! 种选法。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define int ll#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MOD=1e9+7,MAXN=1e7+10;int vis[MAXN],num,fac[MAXN],inv[MAXN];int qpow(int a,int b) &#123; int ans=1; while(b) &#123; if(b&amp;1) ans=ans*a%MOD; a=a*a%MOD; b&gt;&gt;=1; &#125; return ans;&#125;int c(int n,int m) &#123; if(n&lt;m) return 0; return fac[n]*inv[m]%MOD*inv[n-m]%MOD;&#125;signed main() &#123; int l=read(),r=read(),n=r-l+1; REP(i,l,r) &#123; if(vis[i]) continue; num++; for(int j=i+i; j&lt;=r; j+=i) vis[j]=1; &#125; fac[0]=fac[1]=1; REP(i,2,n) fac[i]=fac[i-1]*i%MOD; inv[n]=qpow(fac[n],MOD-2); DREP(i,n-1,0) inv[i]=inv[i+1]*(i+1)%MOD; int ans=0; REP(i,1,n) ans=(ans+i*fac[i-1]%MOD*num%MOD*c(n-num,n-i)%MOD*fac[n-i]%MOD)%MOD; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;//常数过大，开O2过","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"组合","slug":"组合","permalink":"https://www.micdz.cn/tags/%E7%BB%84%E5%90%88/"}]},{"title":"【JOI 2018 Final】美术展览 题解","slug":"JOI2018-artshow-solution","date":"2019-11-01T23:25:49.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/JOI2018-artshow-solution/","link":"","permalink":"https://www.micdz.cn/article/JOI2018-artshow-solution/","excerpt":"JOI 2018 Final","text":"JOI 2018 Final 这场挂分好惨啊😭 核心思路 首先，你所选取的美术品肯定是一个按照尺寸排序的连续区间。因为最终贡献只与最大尺寸与最小尺寸有关，中间的肯定是要全部加上。 观察这个式子 S−(Amax−Amin)=S−Amax+Amin\\begin{aligned} &amp;S-(A_{max}-A_{min})\\\\ =&amp;S-A_{max}+A_{min} \\end{aligned} =​S−(Amax​−Amin​)S−Amax​+Amin​​ 可以直接维护一个后缀max，再 Θ(n)\\Theta(n)Θ(n) 地扫过统计答案。 官方题解强行解释部分分的操作真的很。。大家可以去看看 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define int ll#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=5000000+10,INF=0x3f3f3f3f3f3f;struct work &#123; int s,v;&#125; a[MAXN];bool cmp(work a,work b) &#123; return a.s&lt;b.s;&#125;int jian[MAXN],far[MAXN],qianz[MAXN];signed main() &#123; int n=read(); REP(i,1,n) &#123; a[i].s=read(); a[i].v=read(); &#125; sort(a+1,a+1+n,cmp); REP(i,1,n) qianz[i]=qianz[i-1]+a[i].v; if(0&amp;&amp;n&lt;=5000) &#123; int ans=0; REP(i,1,n) REP(j,i,n) &#123; ans=max(ans,qianz[j]-qianz[i-1]+a[i].s-a[j].s); &#125; printf(&quot;%lld\\n&quot;,ans); return 0; &#125; int sum=0; DREP(i,n,1) &#123; jian[i]=-a[i].s-sum; sum+=a[i].v; &#125; far[n]=n; DREP(i,n-1,1) &#123; if(jian[i]&gt;jian[far[i+1]]) far[i]=i; else far[i]=far[i+1]; &#125; int ans=0; REP(i,1,n) &#123; int l=i,r=far[i]; ans=max(ans,qianz[r]-qianz[l-1]+a[l].s-a[r].s); &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"【NOIP2016】愤怒的小鸟 题解","slug":"NOIP2016-fennudexiaoniao-solution","date":"2019-11-01T12:39:42.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/NOIP2016-fennudexiaoniao-solution/","link":"","permalink":"https://www.micdz.cn/article/NOIP2016-fennudexiaoniao-solution/","excerpt":"NOIP2016","text":"NOIP2016 核心思路 直接搞肯定不行。考虑状压。 设 f(S)f(S)f(S) 表示，射落集合为 SSS 的小猪所需要的最少鸟数。转移就很显然了： {f(0)=0f(S∨linei,j)=min⁡{f(S)+1}f(S∨2i−1)=min⁡{f(S)+1}\\begin{aligned} \\begin{cases} f(0)=0\\\\ f(S\\lor\\mathrm{line}_{i,j})=\\min \\{f(S)+1\\}\\\\ f(S\\lor2^{i-1})=\\min\\{f(S)+1\\} \\end{cases} \\end{aligned} ⎩⎪⎨⎪⎧​f(0)=0f(S∨linei,j​)=min{f(S)+1}f(S∨2i−1)=min{f(S)+1}​​ 其中 linei,j\\mathrm{line}_{i,j}linei,j​ 表示的为经过 i,ji,ji,j 两点的抛物线可以射落的小猪的集合。 在枚举 i,ji,ji,j 的时候考虑 SSS ，找到 S∨2x−1=0S\\lor2^{x-1}=0S∨2x−1=0 的最小正整数，这样由 SSS 拓展的所有点都要经过这个点。就将原来的 Θ(Tn22n)\\Theta(Tn^22^n)Θ(Tn22n) 变为了 Θ(Tn+Tn2n)\\Theta(Tn+Tn2^n)Θ(Tn+Tn2n) 。 Θ(Tn2n)\\Theta(Tn2^n)Θ(Tn2n) 实在和 Θ(Tn22n)\\Theta(Tn^22^n)Θ(Tn22n) 没什么区别啊。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)#define eps 1e-8int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=20+5;double x[MAXN],y[MAXN];int dp[(1&lt;&lt;20)+5],line[MAXN][MAXN];double a,b;void calc(int i,int j) &#123; a=(y[j]-(y[i]*x[j])/x[i])/(x[j]*x[j]-x[i]*x[j]); b=y[i]/x[i]-x[i]*a;&#125;int lowx[(1&lt;&lt;20)+5];int main() &#123; int t=read(); while(t--) &#123; memset(dp,127,sizeof(dp)); memset(line,0,sizeof(line)); dp[0]=0; int n=read(),m=read(); REP(i,1,n) scanf(&quot;%lf%lf&quot;,&amp;x[i],&amp;y[i]); REP(i,1,n) REP(j,1,n) &#123; if(fabs(x[i]-x[j])&lt;eps||x[i]*x[j]==0) continue; calc(i,j); if(a&gt;-eps) continue; REP(k,1,n) if(fabs(a*x[k]*x[k]+b*x[k]-y[k])&lt;=eps) line[i][j]|=(1&lt;&lt;(k-1)); &#125; REP(s,0,(1&lt;&lt;n)-1) &#123; int i=1; while(i&lt;=n&amp;&amp;s&amp;(1&lt;&lt;(i-1))) i++; dp[s|(1&lt;&lt;(i-1))]=min(dp[s|(1&lt;&lt;(i-1))],dp[s]+1); REP(j,1,n) dp[s|line[i][j]]=min(dp[s|line[i][j]],dp[s]+1); &#125; printf(&quot;%d\\n&quot;,dp[(1&lt;&lt;n)-1]); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"状压","slug":"状压","permalink":"https://www.micdz.cn/tags/%E7%8A%B6%E5%8E%8B/"}]},{"title":"【NOIP2014】解方程 题解","slug":"NOIP2014-jiefangcheng-solution","date":"2019-10-31T12:39:49.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/NOIP2014-jiefangcheng-solution/","link":"","permalink":"https://www.micdz.cn/article/NOIP2014-jiefangcheng-solution/","excerpt":"NOIP2014","text":"NOIP2014 核心思路 说实话刚拿到这道题时，除了30pts，没有任何思路。 设原多项式方程的对应函数为： f(x)=a0+a1x+⋯+anxnf(x)=a_0+a_1x+\\cdots+a_nx^n f(x)=a0​+a1​x+⋯+an​xn 题目所求就是 f(x)=0f(x)=0f(x)=0 在 x∈[1,m]x\\in [1,m]x∈[1,m] 的整数解。 考虑 f(x) mod pf(x) \\bmod pf(x)modp ，当 f(x)=0f(x)=0f(x)=0 时显然等于000。 那么直接 Θ(nm)\\Theta(nm)Θ(nm) 暴力枚举 [1,m][1,m][1,m] 并计算答案 f(x) mod pf(x) \\bmod pf(x)modp 是否为000。 选择一个好的模数很重要。 读入的时候用快读，边读边模。 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define int ll#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)const int MAXN=100000+10,MOD=19260817;int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=(x*10+ch-&#x27;0&#x27;)%MOD;ch=getchar();&#125; return x*f;&#125;int a[MAXN],n,m;int f(int x) &#123; int ans=0,prod=1; REP(i,0,n) &#123; ans=(ans+prod*a[i])%MOD; prod=(prod*x)%MOD; &#125; return ans;&#125;int book[MAXN];int ans[MAXN],cnt;signed main() &#123; n=read(),m=read(); REP(i,0,n) a[i]=read(); REP(i,1,m) if(f(i)==0) ans[++cnt]=i; printf(&quot;%lld\\n&quot;,cnt); REP(i,1,cnt) printf(&quot;%lld\\n&quot;,ans[i]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"黑科技","slug":"黑科技","permalink":"https://www.micdz.cn/tags/%E9%BB%91%E7%A7%91%E6%8A%80/"}]},{"title":"【NOIP2012】国王游戏 题解","slug":"NOIP2012-guowangyouxi-solution","date":"2019-10-29T12:48:04.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/NOIP2012-guowangyouxi-solution/","link":"","permalink":"https://www.micdz.cn/article/NOIP2012-guowangyouxi-solution/","excerpt":"NOIP2012","text":"NOIP2012 核心思路 很经典的贪心了。这道题从17年的附中集训第一次看到，到现在才写下总结。 证明很多大佬有非常高级的方法。这里用邻项交换法。 sai biai+1 bi+1\\begin{aligned} &amp;s\\\\ &amp;a_i\\ \\ b_i\\\\ &amp;a_{i+1}\\ \\ b_{i+1} \\end{aligned} ​sai​ bi​ai+1​ bi+1​​ sai+1 bi+1ai bi\\begin{aligned} &amp;s\\\\ &amp;a_{i+1}\\ \\ b_{i+1}\\\\ &amp;a_i\\ \\ b_i \\end{aligned} ​sai+1​ bi+1​ai​ bi​​ 考虑上面的两种情况，假设第二种比第一种更优。 S1=sbi+s+aibi+1S2=sbi+1+s+ai+1biS_1=\\frac{s}{b_i}+\\frac{s+a_i}{b_{i+1}}\\\\ S_2=\\frac{s}{b_{i+1}}+\\frac{s+a_{i+1}}{b_i} S1​=bi​s​+bi+1​s+ai​​S2​=bi+1​s​+bi​s+ai+1​​ 令 S2&lt;S1S_2&lt;S_1S2​&lt;S1​ sbi+1+sbi+aibi+bi&gt;sbi+sbi+1+aibi+1aibi&gt;ai+1bi+1sb_{i+1}+sb_i+a_ib_i+b_i&gt;sb_i+sb_{i+1}+a_ib_{i+1}\\\\ a_ib_i&gt;a_{i+1}b_{i+1} sbi+1​+sbi​+ai​bi​+bi​&gt;sbi​+sbi+1​+ai​bi+1​ai​bi​&gt;ai+1​bi+1​ 所以按照这个排序就是最终的顺序了。 这道题要用到高精度和一定的常数优化，这里就不给出代码了。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"搜索","slug":"搜索","permalink":"https://www.micdz.cn/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"【CSP模拟】merchant 题解","slug":"merchant-solution","date":"2019-10-25T12:59:18.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/merchant-solution/","link":"","permalink":"https://www.micdz.cn/article/merchant-solution/","excerpt":"19.10.18","text":"19.10.18 题目描述 有 nnn 个物品，第 iii 个物品有两个属性 kik_iki​ ， bib_ibi​ ，表示它在时刻 xxx 的价值为 ki×x+bik_i\\times x + b_iki​×x+bi​ 。 当前处于时刻 000 ，你可以选择不超过 mmm 个物品，使得存在某个整数时刻 ttt ， t≥0t \\geq 0t≥0 ，你选择的 所有物品的总价值大于等于 SSS 。 给出 SSS ，求 ttt 的最小值。 n≤105n\\leq10^5n≤105 核心思路 题目显然就是 ∑(kx+b)=∑kx+∑b&gt;s\\sum(kx+b)=\\sum kx+\\sum b&gt;s ∑(kx+b)=∑kx+∑b&gt;s 这个式子非常难维护。 考虑是否具有单调性，显然，这个必然是先减后增的。直接二分答案。 考虑如何二分答案，只需要先检查 000 的位置是否合法，就可以直接忽略掉递减的部分了。 考虑如何check，题目规模要求 Θ(n)\\Theta(n)Θ(n) 地检查。这里有一个玄学操作nth_element，复杂度玄学，可以卡过随机数据。 考试的时候没想清楚这一点，想着有一定的概率二分可以过。然后看到题目有一个subtask是 ∀i,ki&lt;0\\forall i,k_i&lt;0∀i,ki​&lt;0 ，就自己特判了一下 000 的情况，就比别人多了12分。 代码略","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://www.micdz.cn/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"}]},{"title":"【TJOI2013】拯救小矮人 题解","slug":"TJOI2013-xiaoairen-solution","date":"2019-10-25T12:53:29.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/TJOI2013-xiaoairen-solution/","link":"","permalink":"https://www.micdz.cn/article/TJOI2013-xiaoairen-solution/","excerpt":"TJOI2013","text":"TJOI2013 核心思路 将小矮人按逃生的能力排序，然后再做一个背包。 思路比较容易猜到，但是证明不是很简单。 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int INF=0x3f3f3f3f,MAXN=100000+10;int h;struct airen &#123; int a,b;&#125; a[MAXN];bool cmp(airen a,airen b) &#123; return a.a+a.b&lt;b.a+b.b;&#125;int dp[MAXN];int main() &#123; int n=read(); REP(i,1,n) a[i].a=read(),a[i].b=read(); h=read(); sort(a+1,a+1+n,cmp); int sum=0,ans=0; REP(i,1,n) sum+=a[i].a; REP(i,1,n) dp[i]=-INF; dp[0]=sum; REP(i,1,n) DREP(j,i,1) if(a[i].b+dp[j-1]&gt;=h) dp[j]=max(dp[j],dp[j-1]-a[i].a); DREP(i,n,0) if(dp[i]&gt;=0) &#123; ans=i; break; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"贪心","slug":"贪心","permalink":"https://www.micdz.cn/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"【JSOI2011】柠檬 题解","slug":"JSOI2011-ningmeng-solution","date":"2019-10-24T12:41:43.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/JSOI2011-ningmeng-solution/","link":"","permalink":"https://www.micdz.cn/article/JSOI2011-ningmeng-solution/","excerpt":"JSOI2011","text":"JSOI2011 核心思路 M_sea写的是真的好啊 设dpi\\mathrm{dp}_idpi​为前iii个贝壳可以得到的最多柠檬，转移方程显然： dpi=max⁡j=1i{dpj−1+si(ci−cj+1)}=dpj−1+sici2+sicj2−2sicicj+2sici−2sicj+si\\begin{aligned} \\mathrm{dp}_i&amp;=\\max_{j=1}^i\\{\\mathrm{dp}_{j-1}+s_i(c_i-c_j+1)\\}\\\\ &amp;=\\mathrm{dp}_{j-1}+s_ic_i^2+s_ic_j^2-2s_ic_ic_j+2s_ic_i-2s_ic_j+s_i \\end{aligned} dpi​​=j=1maxi​{dpj−1​+si​(ci​−cj​+1)}=dpj−1​+si​ci2​+si​cj2​−2si​ci​cj​+2si​ci​−2si​cj​+si​​ 按照斜率优化的套路，将含iii，jjj分开，转化为一次函数，可以得到： mi=sici2+2sici+si, y=dpi−1+sici2−2sici, k=2ci, x=sicim_i=s_ic_i^2+2s_ic_i+s_i,\\ \\ y=\\mathrm{dp}_{i-1}+s_ic_i^2-2s_ic_i,\\ \\ k=2c_i,\\ \\ x=s_ic_i mi​=si​ci2​+2si​ci​+si​, y=dpi−1​+si​ci2​−2si​ci​, k=2ci​, x=si​ci​ dpi=y−kx+mi\\mathrm{dp}_i=y-kx+m_i dpi​=y−kx+mi​ 答案就在这些点的上凸包上，用一个单调栈维护即可。 求大佬轻D。 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;#define int ll#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125; const int MAXN=100000+10; int s[MAXN],p[MAXN],c[MAXN],dp[MAXN]; int x(int i) &#123;return s[i]*c[i];&#125;int y(int i) &#123;return dp[i-1]+s[i]*c[i]*c[i]-2*s[i]*c[i];&#125; double calc1(int i,int j) &#123; return 1.0*(y(i)-y(j))/(x(i)-x(j));&#125; int calc2(int i,int j) &#123; return dp[j-1]+s[i]*(c[i]-c[j]+1)*(c[i]-c[j]+1);&#125; vector&lt;int&gt; stack[MAXN]; signed main() &#123; int n=read(); REP(i,1,n) s[i]=read(),c[i]=c[p[s[i]]]+1,p[s[i]]=i; REP(i,1,n) &#123; while (stack[s[i]].size()&gt;=2&amp;&amp;calc1(stack[s[i]][stack[s[i]].size()-2],i)&gt;=calc1(stack[s[i]][stack[s[i]].size()-2],stack[s[i]][stack[s[i]].size()-1])) stack[s[i]].pop_back(); stack[s[i]].push_back(i); while (stack[s[i]].size()&gt;=2&amp;&amp;calc2(i,stack[s[i]][stack[s[i]].size()-1])&lt;=calc2(i,stack[s[i]][stack[s[i]].size()-2])) stack[s[i]].pop_back(); dp[i]=calc2(i,stack[s[i]].back()); &#125;//上凸包 printf(&quot;%lld\\n&quot;,dp[n]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.micdz.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://www.micdz.cn/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"}]},{"title":"【HNOI2008】玩具装箱 题解","slug":"HNOI2008-toy-solution","date":"2019-10-23T23:26:06.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/HNOI2008-toy-solution/","link":"","permalink":"https://www.micdz.cn/article/HNOI2008-toy-solution/","excerpt":"HNOI2008","text":"HNOI2008 Tham题目的难度跨度真大。 核心思路 首先有一个很显然的dp，设dpi\\mathrm{dp}_idpi​为前iii个的最小花费 dpi=min⁡j=0i−1{dpj+(i−j−1+sumi−sumj−L)2}\\mathrm{dp}_i=\\min_{j=0}^{i-1}\\{\\mathrm{dp}_j+(i-j-1+\\mathrm{sum}_i-\\mathrm{sum}_j-L)^2\\} dpi​=j=0mini−1​{dpj​+(i−j−1+sumi​−sumj​−L)2} 斜率优化的套路就是把含iii、jjj的分离开来，为了更加方便： ai=sumi+i , bi=sumi+i+L+1a_i=\\mathrm{sum}_i+i\\ ,\\ b_i=\\mathrm{sum}_i+i+L+1\\\\ ai​=sumi​+i , bi​=sumi​+i+L+1 方程转化为： dpi=min⁡j=0i−1[(ai−bj)2+dpj]dpi=(ai−bj)2+dpj\\begin{aligned} \\mathrm{dp}_i&amp;=\\min_{j=0}^{i-1}[(a_i-b_j)^2+\\mathrm{dp}_j]\\\\ \\mathrm{dp}_i&amp;=(a_i-b_j)^2+\\mathrm{dp}_j\\\\ \\end{aligned} dpi​dpi​​=j=0mini−1​[(ai​−bj​)2+dpj​]=(ai​−bj​)2+dpj​​ 2×aibj+dpi−ai2=dpj+bj22\\times a_ib_j+\\mathrm{dp}_i-a_i^2=\\mathrm{dp}_j+b_j^2 2×ai​bj​+dpi​−ai2​=dpj​+bj2​ 再将这个式子看做一个一次函数，aia_iai​是已知的 k=2ai,x=bj,y=dpj+bj2k=2a_i,x=b_j,y=\\mathrm{dp}_j+b_j^2 k=2ai​,x=bj​,y=dpj​+bj2​ y=kx+dpi−ai2y=kx+\\mathrm{dp_i}-a_i^2 y=kx+dpi​−ai2​ dpi=y−kx+ai2\\mathrm{dp}_i=y-kx+a_i^2 dpi​=y−kx+ai2​ 任务是要找到dpi\\mathrm{dp}_idpi​的最小值 数形结合可以理解为，上述直线过点(bj,dpj+bj2)(b_j,\\mathrm{dp}_j+b_j^2)(bj​,dpj​+bj2​)，直线在yyy轴截距增加ai2a_i^2ai2​。 最优解即在这些点的下凸包上。 用单调队列维护一下就可以求出下凸包。边求边统计答案。 ## 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;#define int ll#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=50000+10;int c[MAXN],f[MAXN],q[MAXN],a[MAXN],b[MAXN];double calc(int i,int j) &#123; int yi=f[i]+b[i]*b[i],yj=f[j]+b[j]*b[j]; return 1.0*(yi-yj)/(b[i]-b[j]);&#125;signed main() &#123; int n=read(),L=read()+1,l=1,r=1; REP(i,1,n) c[i]=read()+c[i-1]; REP(i,0,n) a[i]=c[i]+i; REP(i,0,n) b[i]=a[i]+L; REP(i,1,n) &#123; while(l&lt;r&amp;&amp;calc(q[l],q[l+1])&lt;2*a[i]) l++; f[i]=f[q[l]]+(a[i]-b[q[l]])*(a[i]-b[q[l]]); while(l&lt;r&amp;&amp;calc(i,q[r-1])&lt;calc(q[r-1],q[r])) r--; q[++r]=i; &#125; printf(&quot;%lld\\n&quot;,f[n]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.micdz.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"【CF10D】LCIS 题解","slug":"CF10D-solution","date":"2019-10-23T23:26:06.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/CF10D-solution/","link":"","permalink":"https://www.micdz.cn/article/CF10D-solution/","excerpt":"Codeforces Beta Round #10D题","text":"Codeforces Beta Round #10D题 核心思路及完整代码 fi,jf_{i,j}fi,j​表示aaa中前iii个与bbb中前jjj个的LCIS fi,j={fi,j−1, ai≠bjmax⁡k=0j−1{dpi−1,k+1}, bk&lt;ai and ai=bjf_{i,j}= \\begin{cases} \\begin{aligned} &amp;f_{i,j-1},\\ \\ &amp;a_i\\neq b_j\\\\ &amp;\\max_{k=0}^{j-1}\\{dp_{i-1,k}+1\\}, \\ \\ &amp;b_k&lt;a_i\\ and \\ \\ a_i=b_j \\end{aligned} \\end{cases} fi,j​=⎩⎨⎧​​fi,j−1​, k=0maxj−1​{dpi−1,k​+1}, ​ai​​=bj​bk​&lt;ai​ and ai​=bj​​​ 时间复杂度Θ(n3)\\Theta(n^3)Θ(n3) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=500+10;int n,m,a[MAXN],b[MAXN],dp[MAXN][MAXN],ans[MAXN][MAXN];void print(int j) &#123; if(!j) return ; print(ans[n][j]); printf(&quot;%d &quot;,b[j]-1);&#125;int main() &#123; n=read(),m; REP(i,1,n) a[i]=read()+1; m=read(); REP(i,1,m) b[i]=read()+1; REP(i,1,n) REP(j,1,m) &#123; ans[i][j]=ans[i-1][j]; if(a[i]!=b[j]) dp[i][j]=dp[i-1][j]; else &#123; REP(k,0,j-1) if(b[k]&lt;a[i]) &#123; if(dp[i-1][k]+1&gt;dp[i][j]) &#123; dp[i][j]=dp[i-1][k]+1; ans[i][j]=k; &#125; &#125; &#125; &#125; int pos=0,ans=0; REP(i,1,m) if(dp[n][i]&gt;ans) ans=dp[n][i],pos=i; printf(&quot;%d\\n&quot;,ans); print(pos); return 0;&#125; 每次kkk都从000开始检查到j−1j-1j−1浪费了时间，只需要记录下上次的结果和计算一下bj−1b_{j-1}bj−1​与aia_iai​关系即可。 fi,j={fi,j−1, ai≠bjmax⁡{max′,bj−1}+1, bj−1&lt;ai and ai=bjmax′, bj−1≥aif_{i,j}= \\begin{cases} \\begin{aligned} &amp;f_{i,j-1},\\ \\ &amp;a_i\\neq b_j\\\\ &amp;\\max\\{max&#x27;,b_{j-1}\\}+1, \\ \\ &amp;b_{j-1}&lt;a_i\\ and \\ \\ a_i=b_j\\\\ &amp;max&#x27;, \\ \\ &amp;b_{j-1}\\geq a_i \\end{aligned} \\end{cases} fi,j​=⎩⎪⎨⎪⎧​​fi,j−1​, max{max′,bj−1​}+1, max′, ​ai​​=bj​bj−1​&lt;ai​ and ai​=bj​bj−1​≥ai​​​ 时间复杂度Θ(n2)\\Theta(n^2)Θ(n2) 我就没写了，大家去查xgzc、M_sea的啊。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.micdz.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"【NOIP2016】换教室 题解","slug":"LG1850-solution","date":"2019-10-22T20:17:52.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/LG1850-solution/","link":"","permalink":"https://www.micdz.cn/article/LG1850-solution/","excerpt":"NOIP2016","text":"NOIP2016 核心思路 设dpi,j,0/1dp_{i,j,0/1}dpi,j,0/1​表示前iii个教室，提交了jjj个申请，第iii个教室是否成功的最小期望体力。 disi,j\\mathrm{dis}_{i,j}disi,j​表示从iii到jjj的最短距离，Floyd初始化。 下面是完整的转移方程。 dpi,j,0=min⁡{dpi−1,j,0+disci−1,cidpi−1,j,1+(1−ki−1)disci−1,ci+ki−1disdi−1,cidpi,j,1=min⁡{dpi−1,j−1,0+disci−1,ci(1−ki)+disci−1,dikidpi−1,j−1,1+disdi−1,dikiki−1+disdi−1,ciki−1(1−ki)+disci−1,di(1−ki−1)ki+disci−1,ci(1−ki)(1−ki−1)\\begin{aligned} dp_{i,j,0}&amp;=\\min\\begin{cases}dp_{i-1,j,0}+dis_{c_{i-1},c_i}\\\\dp_{i-1,j,1}+(1-k_{i-1})dis_{c_{i-1},c_i}+k_{i-1}dis_{d_{i-1,c_i}}\\end{cases} \\\\ dp_{i,j,1}&amp;=\\min\\begin{cases} dp_{i-1,j-1,0}+dis_{c_{i-1},c_i}(1-k_i)+dis_{c_{i-1},d_i}k_i\\\\dp_{i-1,j-1,1}+dis_{d_{i-1},d_i}k_ik_{i-1}+dis_{d_{i-1},c_i}k_{i-1}(1-k_i)+dis_{c_{i-1},d_i}(1-k_{i-1})k_i+dis{c_{i-1},c_i}(1-k_i)(1-k_{i-1})\\end{cases} \\end{aligned} dpi,j,0​dpi,j,1​​=min{dpi−1,j,0​+disci−1​,ci​​dpi−1,j,1​+(1−ki−1​)disci−1​,ci​​+ki−1​disdi−1,ci​​​​=min{dpi−1,j−1,0​+disci−1​,ci​​(1−ki​)+disci−1​,di​​ki​dpi−1,j−1,1​+disdi−1​,di​​ki​ki−1​+disdi−1​,ci​​ki−1​(1−ki​)+disci−1​,di​​(1−ki−1​)ki​+disci−1​,ci​(1−ki​)(1−ki−1​)​​ 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;#define int ll#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=2000+10,INF=0x3f3f3f;int c[MAXN],d[MAXN],a[MAXN][MAXN];double dp[MAXN][MAXN][2],k[MAXN];signed main() &#123; int n=read(),m=read(),v=read(),e=read(); REP(i,1,n) c[i]=read(); REP(i,1,n) d[i]=read(); REP(i,1,n) scanf(&quot;%lf&quot;,&amp;k[i]); REP(i,0,v) REP(j,0,v) a[i][j]=INF; REP(i,1,v) a[i][i]=a[i][0]=a[0][i]=0; REP(i,1,e) &#123; int x=read(),y=read(),w=read(); a[x][y]=a[y][x]=min(a[x][y],w); &#125; REP(t,1,v) REP(i,1,v) REP(j,1,v) a[i][j]=min(a[i][j],a[i][t]+a[t][j]); REP(i,0,n) REP(j,0,m) dp[i][j][0]=dp[i][j][1]=INF; dp[1][0][0]=dp[1][1][1]=0; DE(&quot;in&quot;); REP(i,2,n) &#123; dp[i][0][0]=dp[i-1][0][0]+a[c[i-1]][c[i]]; REP(j,1,min(i,m)) &#123; dp[i][j][0]=min(dp[i-1][j][0]+a[c[i-1]][c[i]],dp[i-1][j][1]+a[c[i-1]][c[i]]*(1-k[i-1])+a[d[i-1]][c[i]]*k[i-1]); dp[i][j][1]=min(dp[i-1][j-1][0]+a[c[i-1]][c[i]]*(1-k[i])+a[c[i-1]][d[i]]*k[i], dp[i-1][j-1][1]+a[d[i-1]][d[i]]*k[i]*k[i-1]+a[d[i-1]][c[i]]*k[i-1]*(1-k[i])+a[c[i-1]][d[i]]*(1-k[i-1])*k[i]+a[c[i-1]][c[i]]*(1-k[i])*(1-k[i-1])); &#125; &#125; double ans=INF; REP(i,0,m) DE(&quot;%.2lf\\n&quot;,ans=min(ans,min(dp[n][i][1],dp[n][i][0]))); printf(&quot;%.2lf\\n&quot;,ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"期望","slug":"期望","permalink":"https://www.micdz.cn/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"容斥","slug":"容斥","permalink":"https://www.micdz.cn/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"【CF5E】Bindian Signalizing 题解","slug":"CF5E-solution","date":"2019-10-22T12:04:41.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/CF5E-solution/","link":"","permalink":"https://www.micdz.cn/article/CF5E-solution/","excerpt":"Codeforces Beta Round #5E题","text":"Codeforces Beta Round #5E题 核心思路 大佬们用的都是单调栈 。考场没想（想不到）那么多直接打了一个RMQ。 官方题解貌似不是单调栈维护的，实现起来也非常简单。 首先显然的是，全局最高一定不会被两块石头跨过（如果有多个最高，任意一个均可）。那么可以直接从这里断开，将此之前的接到最后，变成一条链。处理起来就简单很多了。 但存在的问题是，一块石头很有可能绕过形成的链的最后一个点与全局最高产生贡献。解决的方案是，在形成的链末尾再补上一个全局最高。还需要减去因此而重复的点。 现在开始统计答案。设li\\mathrm{l}_ili​为iii的左边第一个严格大于iii的石头，rir_iri​同理。cntx\\mathrm{cnt}_xcntx​表示所有高达xxx且位于xxx和yyy之间的山丘。 那么实现就很好做了。 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;#define int ll#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=2000000+10;int h[MAXN],a[MAXN],c[MAXN],l[MAXN],r[MAXN];signed main() &#123;//file(&quot;promise&quot;); int t=1; while(t--) &#123; memset(c,0,sizeof(c)); memset(l,0,sizeof(l)); memset(r,0,sizeof(r)); int n=read(); REP(i,1,n) h[i]=read(); int p=1; REP(i,1,n) if(h[i]&gt;=h[p]) p=i; REP(i,0,n) a[i]=h[(i+p)%n==0?n:(i+p)%n]; // REP(i,0,n) printf(&quot;%d &quot;,a[i]); //a[n]=h[p]; DREP(i,n-1,0) &#123; r[i]=i+1; while(r[i]&lt;n&amp;&amp;a[i]&gt;a[r[i]]) r[i]=r[r[i]]; if(r[i]&lt;n&amp;&amp;a[i]==a[r[i]]) c[i]=c[r[i]]+1,r[i]=r[r[i]]; &#125; int ans=0; REP(i,0,n-1) &#123; ans+=c[i]; if(a[i]!=a[0]) &#123; ans+=2;l[i]=i-1; while(l[i]&gt;0&amp;&amp;a[i]&gt;=a[l[i]]) l[i]=l[l[i]]; if(l[i]==0&amp;&amp;r[i]==n) ans--; &#125; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"单调栈","slug":"单调栈","permalink":"https://www.micdz.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"【CF859E】Desk Disorder 题解","slug":"CF859E-solution","date":"2019-10-20T23:27:21.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/CF859E-solution/","link":"","permalink":"https://www.micdz.cn/article/CF859E-solution/","excerpt":"MemSQL Start UP 3.0 - Round 1E题","text":"MemSQL Start UP 3.0 - Round 1E题 核心思路 首先，对于每一个人，都只有一种或两种选法。 那么将人与位置对应连两条边。所形成的的图可以分为以下三种情况。 无环图（树），有x−1x-1x−1 个椅子与xxx个点，有xxx种情况 这个图中包含一个非自环的环，整个图都是有前后依赖的，确定一条边整个图的取法就确定了，那么有222种情况 这个图中包含了一个自环。整个图都被自环锁定，只有一种情况 最后用乘法原理把情况统计起来。 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=200000+10,MOD=1e9+7;int fa[MAXN],size[MAXN],selfloop[MAXN],loop[MAXN];int find(int x) &#123; if(fa[x]==x) return fa[x]; return fa[x]=find(fa[x]);&#125;int link(int x,int y) &#123; fa[find(x)]=find(y);&#125;int main() &#123; int n=read(); REP(i,1,(n&lt;&lt;1)) fa[i]=i,size[i]=1; ll ans=1; REP(i,1,n) &#123; int u=read(),v=read(); if(u==v) &#123;selfloop[u]=1;continue;&#125; u=find(u),v=find(v); if(u!=v) fa[u]=v,selfloop[v]|=selfloop[u],size[v]+=size[u]; else loop[u]=1; &#125; REP(i,1,(n&lt;&lt;1)) if(find(i)==i&amp;&amp;!selfloop[i]) &#123; if(loop[i]) ans=1ll*ans*2; else ans=1ll*ans*size[i]; ans%=MOD; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【POI2015】KIN 题解","slug":"LG3582-solution","date":"2019-10-20T23:12:02.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/LG3582-solution/","link":"","permalink":"https://www.micdz.cn/article/LG3582-solution/","excerpt":"洛谷P3582","text":"洛谷P3582 核心思路 此题与求解最大子段和唯一的区别在于，每一部电影如果重复则不能计入贡献。 处理起来比较巧妙。 我们从左往右扫过每一部电影。假设扫到了第iii部，当前求解的ansi\\mathrm{ans}_iansi​就是1−i1-i1−i部电影的子序列电影产生贡献的最大值。 考虑如何高效地处理这个问题。对于第一次出现的电影，直接在对应位置+wi+w_i+wi​，为了去除重复的贡献，在第二次出现这部电影时，我们将上一次出现的位置更改为−wi-w_i−wi​，在第二次出现的位置设为wiw_iwi​。这样当同时选到第二个与第一个同样的电影时的贡献为000，而单独选择第二个电影的贡献可以直接包含（即不选到第一个相同的电影），单独包含第一个电影的贡献已经计算在了ansi−1\\mathrm{ans}_{i-1}ansi−1​中。选到第三个相同电影时，为了避免多次减去，需要将第一个相同电影位置处设为0，第二次位置处设为−wi-w_i−wi​，当前位置设为wiw_iwi​，如此往复。 最终答案就为 max⁡i=1n{ansi}\\max_{i=1}^n\\{ans_i\\} i=1maxn​{ansi​} 是不是非常ZZ。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;#define int ll#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=1000000+10,INF=0x3f3f3f3f;int a[MAXN];struct SegmentTree &#123; int l,r,prel,prer,res,sum; #define l(x) tree[x].l #define r(x) tree[x].r #define prel(x) tree[x].prel #define prer(x) tree[x].prer #define res(x) tree[x].res #define sum(x) tree[x].sum&#125; tree[MAXN&lt;&lt;2];void pushup(int p) &#123; sum(p)=sum(p*2)+sum(p*2+1); prel(p)=max(prel(p*2),sum(p*2)+prel(p*2+1)); prer(p)=max(prer(p*2+1),sum(p*2+1)+prer(p*2)); res(p)=max(prer(p*2)+prel(p*2+1),max(res(p*2),res(p*2+1)));&#125;void build(int p,int l,int r) &#123; l(p)=l,r(p)=r; if(l==r) &#123; return ; &#125; int mid=(l+r)&gt;&gt;1; build(p*2,l,mid); build(p*2+1,mid+1,r);&#125;void change(int p,int x,int d) &#123; if(l(p)==r(p)) &#123; prel(p)=prer(p)=res(p)=sum(p)=d; return ; &#125; int mid=(l(p)+r(p))&gt;&gt;1; if(x&lt;=mid) change(p*2,x,d); else change(p*2+1,x,d); pushup(p);&#125;int f[MAXN],pre[MAXN],last[MAXN];signed main() &#123; int n=read(),m=read(); REP(i,1,n) f[i]=read(); REP(i,1,m) a[i]=read(); build(1,1,n); int ans=0; REP(i,1,n) &#123; pre[i]=last[f[i]],last[f[i]]=i; if(pre[i]) change(1,pre[i],-a[f[i]]); if(pre[pre[i]]) change(1,pre[pre[i]],0); change(1,i,a[f[i]]); ans=max(ans,res(1)); &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://www.micdz.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"最大子段和","slug":"最大子段和","permalink":"https://www.micdz.cn/tags/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/"}]},{"title":"【SDOI2015】寻宝游戏 题解","slug":"SDOI2015-xunbaoyouxi-solution","date":"2019-10-18T23:27:15.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/SDOI2015-xunbaoyouxi-solution/","link":"","permalink":"https://www.micdz.cn/article/SDOI2015-xunbaoyouxi-solution/","excerpt":"SDOI2015","text":"SDOI2015 核心思路 题目要求的就是关键点的极小联通子树。可以算半个结论题了。这个结论也不难想 再求出图的DFS序之后，所有关键点{a1,a2,...,an}\\{a_1,a_2,...,a_n\\}{a1​,a2​,...,an​}的极小联通子树的边权和的两倍为 ∑i=1n−1dist(ai,ai+1+dist(an,a1))\\sum_{i=1}^{n-1}\\mathrm{dist}(a_i,a_{i+1}+\\mathrm{dist}(a_n,a_1)) i=1∑n−1​dist(ai​,ai+1​+dist(an​,a1​)) 手玩一下很好理解。 那么每次修改xxx的贡献就为 dist(x,pre)+dist(x,nxt)−dist(pre,nxt)\\mathrm{dist}(x,pre)+\\mathrm{dist}(x,nxt)-\\mathrm{dist}(pre,nxt) dist(x,pre)+dist(x,nxt)−dist(pre,nxt) dist\\mathrm{dist}dist就拿LCA直接维护就好了，找前驱和后继用STLset最方便 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;set&gt;using namespace std;#define int ll#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=100000+10;int head[MAXN],_next[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1],weigh[MAXN&lt;&lt;1],cnt;void addedge(int u,int v,int w) &#123; cnt++; _next[cnt]=head[u]; head[u]=cnt; to[cnt]=v; weigh[cnt]=w;&#125;int dfn[MAXN],tot,fa[MAXN][21],dept[MAXN],dist[MAXN];int lca(int u,int v) &#123; if(dept[u]&gt;dept[v]) swap(u,v); int len=dept[v]-dept[u]; DREP(i,20,0) if((1&lt;&lt;i)&amp;len) v=fa[v][i]; if(u==v) return u; DREP(i,20,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0];&#125;int dis(int u,int v) &#123; return dist[u]+dist[v]-2*dist[lca(u,v)];&#125;int have[MAXN],pos[MAXN],id[MAXN];void dfs(int u,int f) &#123; dfn[u]=++tot;id[tot]=u; for(int i=head[u]; i; i=_next[i]) &#123; int v=to[i]; if(dfn[v]) continue; fa[v][0]=u; dept[v]=dept[u]+1; dist[v]=dist[u]+weigh[i]; dfs(v,u); &#125;&#125;set&lt;int&gt; s;signed main() &#123; int n=read(),m=read(); REP(i,1,n-1) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; dfs(1,0); REP(j,1,20) REP(i,1,n) fa[i][j]=fa[fa[i][j-1]][j-1]; int ans=0; REP(i,1,m) &#123; int x=dfn[read()],y,z; set&lt;int&gt; :: iterator it; if(!have[id[x]]) &#123; s.insert(x); y=id[(it=s.lower_bound(x))==s.begin()?*--s.end():*--it]; z=id[(it=s.upper_bound(x))==s.end()?*s.begin():*it]; x=id[x]; ans+=(dis(x,y)+dis(x,z)-dis(y,z)); have[x]=1; &#125; else &#123; y=id[(it=s.lower_bound(x))==s.begin()?*--s.end():*--it]; z=id[(it=s.upper_bound(x))==s.end()?*s.begin():*it]; s.erase(x); x=id[x]; ans-=(dis(x,y)+dis(x,z)-dis(y,z)); have[x]=0; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"LCA","slug":"LCA","permalink":"https://www.micdz.cn/tags/LCA/"}]},{"title":"【NOI2016】区间 题解","slug":"NOI2016qujian-solution","date":"2019-10-18T23:09:26.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/NOI2016qujian-solution/","link":"","permalink":"https://www.micdz.cn/article/NOI2016qujian-solution/","excerpt":"NOI2016","text":"NOI2016 核心思路 答案只跟区间长度有关，代价只与长度最大值和长度最小值有关。 显然优先取长度短的，再向长区间拓展。确定了最短的和最长的区间，中间的区间对答案就没有任何意义，就可以全部取。 那么将区间按照长度排序，以尺取法的思想进行拓展。 考虑怎么统计是否有区间被全部覆盖，线段树直接暴力加减即可。 当然，lll和rrr那么大，肯定是要离散化的。 复杂度Θ(nlog⁡2n)\\Theta(n\\log^2 n)Θ(nlog2n)。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define int ll#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=1000000+10,INF=0x3f3f3f3f;int q[MAXN];struct edge &#123; int l,r,len;&#125; a[MAXN];bool cmp(edge a,edge b) &#123; return a.len&lt;b.len;&#125;struct SegmentTree &#123; int l,r,maxx,add; #define l(x) tree[x].l #define r(x) tree[x].r #define maxx(x) tree[x].maxx #define add(x) tree[x].add&#125; tree[MAXN&lt;&lt;2];void build(int p,int l,int r) &#123; l(p)=l,r(p)=r; if(l==r) &#123;maxx(p)=0; return ;&#125; int mid=(l+r)&gt;&gt;1; build(p*2,l,mid); build(p*2+1,mid+1,r);&#125;void spread(int p) &#123; if(add(p)) &#123; add(p*2)+=add(p); add(p*2+1)+=add(p); maxx(p*2)=maxx(p*2)+add(p); maxx(p*2+1)=maxx(p*2+1)+add(p); add(p)=0; &#125;&#125;void change(int p,int l,int r,int d) &#123; if(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123; add(p)+=d; maxx(p)=maxx(p)+d; return ; &#125; spread(p); int mid=(l(p)+r(p))&gt;&gt;1; if(l&lt;=mid) change(p*2,l,r,d); if(r&gt;mid) change(p*2+1,l,r,d); maxx(p)=max(maxx(p*2),maxx(p*2+1));&#125;signed main() &#123; int n=read(),m=read(),cnt=0; REP(i,1,n) a[i].l=read(),a[i].r=read(),a[i].len=a[i].r-a[i].l,q[++cnt]=a[i].l,q[++cnt]=a[i].r; sort(q+1,q+1+cnt); int num=unique(q+1,q+1+cnt)-q-1; sort(a+1,a+1+n,cmp); int st=INF,ed=0; REP(i,1,n) &#123; a[i].l=lower_bound(q+1,q+1+num,a[i].l)-q; a[i].r=lower_bound(q+1,q+1+num,a[i].r)-q; &#125; build(1,1,num); int l=0,r=0,ans=INF; while(r&lt;n) &#123; while(maxx(1)&lt;m&amp;&amp;r&lt;=n) &#123; r++; change(1,a[r].l,a[r].r,1); &#125; if(maxx(1)&lt;m) break; while(maxx(1)&gt;=m&amp;&amp;r&gt;=l) &#123; l++; change(1,a[l].l,a[l].r,-1); ans=min(ans,a[r].len-a[l].len); &#125; &#125; printf(&quot;%lld \\n&quot;,ans==INF?-1:ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"线段树","slug":"线段树","permalink":"https://www.micdz.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"尺取法","slug":"尺取法","permalink":"https://www.micdz.cn/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"}]},{"title":"【BZOJ3714】Kuglarz 题解","slug":"BZOJ3714-solution","date":"2019-10-17T12:05:59.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/BZOJ3714-solution/","link":"","permalink":"https://www.micdz.cn/article/BZOJ3714-solution/","excerpt":"PA2014","text":"PA2014 核心思路 知道了 aaa 到 bbb 、 bbb 到 ccc 的奇偶性，就知道了 aaa 到 ccc 的奇偶 性。要知道任意两点间的奇偶性就只需要保证图联通即可，问题转化为最小生成树。由于是一个完全图，kruskal的复杂度为 O(n2log⁡n2)O(n^2\\log n^2)O(n2logn2) 的会TLE，只能上prim。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define int ll#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=2000+10,INF=0x3f3f3f3f3f3f3f3f;int a[MAXN][MAXN];int dist[MAXN],vis[MAXN];Signed main () &#123; int n=read(),cnt=0; REP(i,1,n) REP(j,i,n) a[i-1][j]=a[j][i-1]=read(); REP(i,0,n) dist[i]=a[1][i]; vis[1]=1; int ans=0; REP(u,1,n) &#123; int minn=INF,pos; REP(i,0,n) if(!vis[i]&amp;&amp;dist[i]&lt;minn) minn=dist[i],pos=i; ans+=minn;vis[pos]=1; REP(i,0,n) dist[i]=min(dist[i],a[pos][i]); &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://www.micdz.cn/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"【CF891C】Envy 题解","slug":"CF891C-solution","date":"2019-10-16T23:11:19.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/CF891C-solution/","link":"","permalink":"https://www.micdz.cn/article/CF891C-solution/","excerpt":"Codeforces Round #446 (Div. 1)C题","text":"Codeforces Round #446 (Div. 1)C题 核心思路 这道题考察了一些最小生成树与边有关的的性质：对于一个图的所有 MST\\mathrm{MST}MST，每种边权的边的数量都相等。 那么我们可以分别考虑每一种边权的边，将其还原至加入这条边以前的状态然后再检验是否有环。 考虑如何还原到此前的状态，可持久化并查集，直接将加入该种边时两端点的联通块记录下来，在询问这种边的时候直接更改即可。 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=500000+10;struct edge &#123; int u,v,w,id;&#125; a[MAXN],p[MAXN];bool cmp1(edge a,edge b) &#123; return a.w&lt;b.w;&#125;bool cmp2(edge a,edge b) &#123; return a.id&lt;b.id;&#125;int fa[MAXN];int find(int x) &#123; if(fa[x]==x) return x; return fa[x]=find(fa[x]);&#125;int link(int x,int y) &#123; fa[find(x)]=find(y);&#125;int main() &#123; int n=read(),m=read(); REP(i,1,m) a[i]=(edge)&#123;read(),read(),read(),i&#125;; sort(a+1,a+1+m,cmp1); REP(i,1,n) fa[i]=i; for(int i=1,j=1; i&lt;=m; i=j=j+1) &#123; while(j&lt;m&amp;&amp;a[j].w==a[j+1].w) j++; REP(k,i,j) a[k].u=find(a[k].u),a[k].v=find(a[k].v); REP(k,i,j) &#123; if(find(a[k].u)==find(a[k].v)) continue; link(a[k].u,a[k].v); &#125; &#125; sort(a+1,a+1+m,cmp2); int q=read(); REP(t,1,q) &#123; bool flag=1; int w=read(); REP(i,1,w) p[i]=a[read()]; sort(p+1,p+1+w,cmp1); for(int i=1,j=1; i&lt;=w; i=j=j+1) &#123; while(j&lt;w&amp;&amp;p[j].w==p[j+1].w) j++; REP(k,i,j) fa[p[k].u]=p[k].u,fa[p[k].v]=p[k].v; REP(k,i,j) &#123; if(find(p[k].u)==find(p[k].v)) flag=0; link(p[k].u,p[k].v); &#125; &#125; if(flag) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://www.micdz.cn/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"【CF1051F】The Shortest Statement 题解","slug":"CF1051F-solution","date":"2019-10-16T12:47:06.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/CF1051F-solution/","link":"","permalink":"https://www.micdz.cn/article/CF1051F-solution/","excerpt":"Educational Codeforces Round 51 (Rated for Div. 2)E题","text":"Educational Codeforces Round 51 (Rated for Div. 2)E题 也许是一道码题 核心思路 直接floyd是肯定过不了的，注意到m−n≤20m-n\\leq20m−n≤20，那么这个图可以看做为一棵树和至多20条非树边构成的。那么在树上求距离就很简单了，对于剩下的20条非树边直接暴力从两个端点开始求一遍最短路，在所有经过至少一条非树边与树上距离中找到最小值即为答案。 u→vu\\to vu→v至少经过一条(u0,v0)(u_0,v_0)(u0​,v0​)的边的最小值为min⁡{distid(u0)u+distid(v0)v}\\min \\{\\mathrm{dist}_{id(u_0)}u+\\mathrm{dist}_{id(v_0)}v\\}min{distid(u0​)​u+distid(v0​)​v}。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define int ll #define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=200000+10,INF=0x3f3f3f3f3f3f3f;struct edge &#123; int u,v,w;&#125; a[MAXN];int f[MAXN];int find(int x) &#123; if(f[x]==x) return x; return f[x]=find(f[x]);&#125;int link(int x,int y) &#123; f[find(x)]=find(y);&#125;int head[MAXN],_next[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1],weigh[MAXN&lt;&lt;1],cnt;void addedge(int u,int v,int w) &#123; cnt++; _next[cnt]=head[u]; head[u]=cnt; to[cnt]=v; weigh[cnt]=w;&#125;queue&lt;int&gt; q1;int n,m,dept[MAXN],dis[MAXN],fa[MAXN][25];void bfs(int s) &#123; q1.push(s); while(!q1.empty()) &#123; int u=q1.front();q1.pop(); for(int i=head[u]; i; i=_next[i]) &#123; int v=to[i]; if(fa[u][0]==v) continue; fa[v][0]=u; dept[v]=dept[u]+1; dis[v]=dis[u]+weigh[i]; q1.push(v); &#125; &#125;&#125;priority_queue&lt;pair&lt;int,int&gt; &gt; q;int book[MAXN],dist[44][MAXN];void dij(int op,int s) &#123; q.push(make_pair(0,s)); REP(i,1,n) book[i]=0; REP(i,1,n) dist[op][i]=INF; dist[op][s]=0; while(!q.empty()) &#123; int u=q.top().second;q.pop(); if(book[u]) continue; book[u]=1; for(int i=head[u]; i; i=_next[i]) &#123; int v=to[i]; if(dist[op][v]&gt;dist[op][u]+weigh[i]) &#123; dist[op][v]=dist[op][u]+weigh[i]; q.push(make_pair(-dist[op][v],v)); &#125; &#125; &#125; return ;&#125; int used[MAXN];int lca(int u,int v) &#123; if(dept[u]&gt;dept[v]) swap(u,v); int len=dept[v]-dept[u]; DREP(i,19,0) if((1&lt;&lt;i)&amp;len) v=fa[v][i]; if(u==v) return u; DREP(i,19,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0];&#125;signed main() &#123; n=read(),m=read(); REP(i,1,m) a[i].u=read(),a[i].v=read(),a[i].w=read(); REP(i,1,n) f[i]=i; int num=0; REP(i,1,m) &#123; if(find(a[i].u)==find(a[i].v)) continue; link(a[i].u,a[i].v); addedge(a[i].u,a[i].v,a[i].w); addedge(a[i].v,a[i].u,a[i].w); used[i]=1; num++; if(num==n-1) break; &#125; bfs(1); REP(j,1,19) REP(i,1,n) fa[i][j]=fa[fa[i][j-1]][j-1]; REP(i,1,m) if(!used[i]) addedge(a[i].u,a[i].v,a[i].w),addedge(a[i].v,a[i].u,a[i].w); int op=0; REP(i,1,m) &#123; if(!used[i]) &#123; dij(++op,a[i].u); dij(++op,a[i].v); &#125; &#125; int q=read(); REP(i,1,q) &#123; int u=read(),v=read(); int ans=dis[u]+dis[v]-2*dis[lca(u,v)]; REP(j,1,op) ans=min(ans,dist[j][u]+dist[j][v]); printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://www.micdz.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"LCA","slug":"LCA","permalink":"https://www.micdz.cn/tags/LCA/"}]},{"title":"【CF1037D】Valid BFS? 题解","slug":"CF1037D-solution","date":"2019-10-15T23:16:42.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/CF1037D-solution/","link":"","permalink":"https://www.micdz.cn/article/CF1037D-solution/","excerpt":"Manthan, Codefest 18 (rated, Div. 1 + Div. 2)D题","text":"Manthan, Codefest 18 (rated, Div. 1 + Div. 2)D题 核心思路 直接照题意模拟bfs的过程，顺序加入每个点与当前点的出边对应。用一个set维护最为直观。 nzr表示让我们不要学习这种Θ(nlog⁡n)\\Theta(n\\log n)Θ(nlogn)的做法。 完整代码 我的代码太丑了，大家看nzr神仙的代码吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int N=200010;int n,m;struct edge&#123; int to,next;&#125;e[N&lt;&lt;1];int head[N],cnt;void adde(int a,int b)&#123; e[++cnt].to=b;e[cnt].next=head[a]; head[a]=cnt;&#125;queue&lt;int&gt;q;int dep[N];int a[N];void out()&#123; puts(&quot;No&quot;); exit(0);&#125;int now=1;void bfs()&#123; dep[1]=1; q.push(1); while(!q.empty()) &#123; int x=q.front(); q.pop(); int ct=0; for(int i=head[x];i;i=e[i].next) &#123; int v=e[i].to; if(dep[v])continue; dep[v]=dep[x]+1;ct++; &#125; for(int i=now+1;i&lt;=now+ct;i++) if(!dep[a[i]])out(); else q.push(a[i]); now=now+ct; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); int u,v; for(int i=1;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;u,&amp;v),adde(u,v),adde(v,u); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); if(a[1]!=1)out(); bfs(); puts(&quot;Yes&quot;); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模拟","slug":"模拟","permalink":"https://www.micdz.cn/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"【CF525D】Arthur and Walls 题解","slug":"CF525D-solution","date":"2019-09-23T12:26:06.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/CF525D-solution/","link":"","permalink":"https://www.micdz.cn/article/CF525D-solution/","excerpt":"Codeforces Round #297 (Div. 2) D题","text":"Codeforces Round #297 (Div. 2) D题 虽然是在贪心题的集训里面的，但是这题好像和贪心没有什么关系。 题目大意 给出一个n×mn\\times mn×m的矩阵，里面有星号和点两种符号，要求把最少的星号变成点，使得点的联通块构成一个矩形。求最少需要变几个星号。 核心思路 直接寻找矩形、合并是非常困难的。相交重叠的部分不好统计，并且每合并两个矩形还有可能影响到此前已经合并好的矩形。玄学合并也许可以卡过去 正解非常之不好想，思路相当巧妙。对于每一个星号，当它的周边有三个点，时，这个星号就必须要改为点。这样修改下去，直到没有一个星号的周边有三个点。 考虑如何修改，因为每修改一个星号为点，都只会对这个点上下左右四个方向的8个点产生影响，bfs的时候把上下左右四个方向丢进队列即可。 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define ll long long#define DE(...) fprintf(stderr,__VA_ARGS__)#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)//#define int llint read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=2000+10;char a[MAXN][MAXN];queue&lt;pair&lt;int,int&gt; &gt; q;int n,m;int tx[]=&#123;0,1,-1,1,-1&#125;;int ty[]=&#123;0,-1,1,1,-1&#125;;void bfs() &#123; while(!q.empty()) &#123; int x=q.front().first,y=q.front().second; q.pop(); REP(i,1,4) &#123; int xx=x+tx[i],yy=y+ty[i]; if(xx&gt;n||yy&gt;m||xx&lt;1||yy&lt;1) continue; if(a[x][yy]+a[xx][y]+a[xx][yy]+a[x][y]==3*&#x27;.&#x27;+&#x27;*&#x27;) &#123; if(a[x][yy]==&#x27;*&#x27;) q.push(make_pair(x,yy)),a[x][yy]=&#x27;.&#x27;; if(a[xx][y]==&#x27;*&#x27;) q.push(make_pair(xx,y)),a[xx][y]=&#x27;.&#x27;; if(a[xx][yy]==&#x27;*&#x27;) q.push(make_pair(xx,yy)),a[xx][yy]=&#x27;.&#x27;; &#125; &#125; &#125;&#125;int main() &#123; n=read(),m=read(); REP(i,1,n) &#123; REP(j,1,m) a[i][j]=getchar(); getchar(); &#125; REP(i,1,n) REP(j,1,m) if(a[i][j]==&#x27;.&#x27;) q.push(make_pair(i,j)); bfs(); REP(i,1,n) &#123;REP(j,1,m) printf(&quot;%c&quot;,a[i][j]); puts(&quot;&quot;);&#125;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"2022高考倒计时","slug":"time","date":"2019-09-13T10:54:35.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/time/","link":"","permalink":"https://www.micdz.cn/article/time/","excerpt":"2022高考倒计时是MicDZ由2019中考倒计时项目更改得来。","text":"2022高考倒计时是MicDZ由2019中考倒计时项目更改得来。 访问https://t.micdz.cn/ 项目地址GitHub","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"https://www.micdz.cn/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"【CF1203E】Boxers 题解","slug":"CF1203E-solution","date":"2019-08-14T15:16:44.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/CF1203E-solution/","link":"","permalink":"https://www.micdz.cn/article/CF1203E-solution/","excerpt":"Codeforces Round #579 (Div. 3) E题","text":"Codeforces Round #579 (Div. 3) E题 题目大意 给定你nnn 个数，你可以对每个数加一或减一或不变，求使最后序列不同数最多的个数。 核心思路 将nnn个数排序，然后从小到大对每个数优先减一，再不济就不变，再不济就加一。这是因为，如果你优先加一很有可能就会错过最小的数减一这个答案。 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt; using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define DE(...) fprintf(stderr,__VA_ARGS__);#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)#define ll long long int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125; const ll INF=0x3f3f3f,MAXN=150000+10; int a[MAXN],have[MAXN]; int main() &#123; int n=read(); REP(i,1,n) a[i]=read(); sort(a+1,a+1+n); int ans=0; REP(i,1,n) &#123; if(have[a[i]-1]||a[i]-1&lt;=0) &#123; if(have[a[i]]) &#123; if(have[a[i]+1]) continue; else have[a[i]+1]=1,ans++; &#125; else have[a[i]]=1,ans++; &#125; else have[a[i]-1]=1,ans++; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"贪心","slug":"贪心","permalink":"https://www.micdz.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"排序","slug":"排序","permalink":"https://www.micdz.cn/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"【CF1203D】Remove the Substring 题解","slug":"CF1203D-solution","date":"2019-08-14T15:16:40.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/CF1203D-solution/","link":"","permalink":"https://www.micdz.cn/article/CF1203D-solution/","excerpt":"Codeforces Round #579 (Div. 3) D题","text":"Codeforces Round #579 (Div. 3) D题 题目大意 给定你字符串sss 与字符串ttt，求解最多能从sss中删去多少个元素使得sss中仍包含ttt为子串（不要求连续，保证给定的ttt为sss的子串）。 核心思路 D1的暴力十分好写，但码量似乎比D2还大些。 O(n2)O(n^2)O(n2) 枚举左右端点，暴力加点然后判断加完后的串还有没有ttt这个子串。正宗的暴力写法。 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//submit on LG#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt; using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define DE(...) fprintf(stderr,__VA_ARGS__);#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)#define ll long long int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125; const ll INF=0x3f3f3f,MAXN=200+10; char s[MAXN],t[MAXN],now[MAXN];int lens,lent; bool check(int l,int r) &#123; int cnt=0; REP(i,1,l-1) now[++cnt]=s[i]; REP(i,r+1,lens) now[++cnt]=s[i]; int find=1; //printf(&quot;cnt: %d\\n&quot;,cnt); REP(i,1,cnt) &#123; if(now[i]==t[find]) find++; &#125; if(find==lent+1) return 1; return 0;&#125; int main() &#123; scanf(&quot;%s&quot;,s+1); scanf(&quot;%s&quot;,t+1); lens=strlen(s+1),lent=strlen(t+1); int ans=0; REP(i,1,lens) REP(j,i,lens) &#123; if(check(i,j)) &#123; ans=max(ans,j-i+1); //printf(&quot;%d %d\\n&quot;,i,j); &#125; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125; D2的数据范围很容易联想到二分答案，但是有了NOIp2018年积木大赛的教训后，看到10510^5105也要提防一下是不是线性的做法。 首先线性地扫一遍对于ttt中的每一个一个位置iii，求出它之前在sss中最早能够被满足的位置，再从右边扫一遍。那么得到这个位置之后我们就可以知道任意一段区间是否能够满足。最后再线性地统计一下答案即可。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"暴力","slug":"暴力","permalink":"https://www.micdz.cn/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"线性","slug":"线性","permalink":"https://www.micdz.cn/tags/%E7%BA%BF%E6%80%A7/"}]},{"title":"【CF1203C】Common Divisors 题解","slug":"CF1203C-solution","date":"2019-08-14T15:16:32.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/CF1203C-solution/","link":"","permalink":"https://www.micdz.cn/article/CF1203C-solution/","excerpt":"Codeforces Round #579 (Div. 3) C题","text":"Codeforces Round #579 (Div. 3) C题 题目大意 给定你nnn个数字组成的数列，求解能将这nnn个数都整除的数的个数有多少。 核心思路 找到这nnn个数的gcd⁡\\gcdgcd，然后求解这个gcd⁡\\gcdgcd的因数个数即可。但是由于数字过大，需要用Θ(a)\\Theta(\\sqrt a)Θ(a​)的复杂度求解。 nnn个数的GCD求解方法可以参考：gcd⁡(a,b,c)=gcd⁡(gcd⁡(a,b),c)\\gcd(a,b,c)=\\gcd(\\gcd(a,b),c)gcd(a,b,c)=gcd(gcd(a,b),c) 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt; using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define DE(...) fprintf(stderr,__VA_ARGS__);#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)#define ll long long ll read() &#123; ll x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125; const ll INF=0x3f3f3f,MAXN=400000+10; ll a[MAXN]; ll gcd(ll a,ll b)&#123; ll t; while(b) &#123; t=a; a=b; b=t%b; &#125; return a;&#125; ll count(ll n)&#123; ll s=1; for(ll i=2; i*i&lt;=n; i++) &#123; if(n%i==0)&#123; ll a=0; while(n%i==0) &#123; n/=i; a++; &#125; s=s*(a+1); &#125; &#125; if(n&gt;1) s=s*2; return s;&#125; int main() &#123; ll n=read(); REP(i,1,n) a[i]=read(); ll ans=gcd(a[1],a[2]); REP(i,3,n) ans=gcd(ans,a[i]); printf(&quot;%lld\\n&quot;,count(ans)); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【CF1203B】Equal Rectangles 题解","slug":"CF1203B-solution","date":"2019-08-14T15:16:19.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/CF1203B-solution/","link":"","permalink":"https://www.micdz.cn/article/CF1203B-solution/","excerpt":"Codeforces Round #579 (Div. 3) B题","text":"Codeforces Round #579 (Div. 3) B题 题目大意 给定你4∗n4*n4∗n个小木条，让你检测是否能组成nnn个面积相等的长方形。 核心思路 考虑到组成长方形的问题，必须要有2∗n2*n2∗n组相同的小木条才能构成长方形。首先将序列排序，从小到大抽出奇数位的与偶数位的查看是否相等，然后存入一个bbb数组中。 对于bbb数组中的任意两个数字都可以构成一个以他们为宽和高的长方形。 考虑使长方形面积相等的问题。 由上述的推到可得出 ∀bi(i&lt;n),bi≤bi+1\\forall b_i(i&lt; n),b_i\\leq b_{i+1} ∀bi​(i&lt;n),bi​≤bi+1​ 那么考虑bnb_nbn​的搭配方式，如果bnb_nbn​选择了b1b_1b1​，那么组成的长方形面积则为bn×b1b_n\\times b_1bn​×b1​，没有问题；如果选择b2b_2b2​，那么组成的长方形为bn×b2b_n\\times b_2bn​×b2​，此时的b1b_1b1​ 无论与谁进行组合都不可能与bn×b2b_n\\times b_2bn​×b2​相等。 所以首尾搭配是唯一的解决办法。如果首位依次向内不能保证乘积相等的话就没有对应的组合方法就输出 NO即可。 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt; using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define DE(...) fprintf(stderr,__VA_ARGS__);#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)#define ll long long int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125; const int INF=0x3f3f3f,MAXN=10000+10; int a[MAXN],b[MAXN]; int main() &#123; int t=read(); while(t--) &#123; int n=read(); REP(i,1,4*n) a[i]=read(); sort(a+1,a+1+4*n); bool flag=0; int cnt=1; for(int i=1; i&lt;=4*n-1; i+=2) &#123; if(a[i]==a[i+1]) b[cnt++]=a[i]; else flag=1; &#125; int times=b[1]*b[2*n]; REP(l,2,n) &#123; int r=2*n-l+1; if(b[l]*b[r]!=times) flag=1; &#125; if(flag) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【CF1203A】Circle of Students 题解","slug":"CF1203A-solution","date":"2019-08-14T15:16:02.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/CF1203A-solution/","link":"","permalink":"https://www.micdz.cn/article/CF1203A-solution/","excerpt":"Codeforces Round #579 (Div. 3) A题","text":"Codeforces Round #579 (Div. 3) A题 题目大意 nnn个小朋友围坐一圈，要求从111号小朋友开始报数，依次以顺时针或逆时针报数，如能报到nnn则输出YES否则输出NO。 核心思路 首先想到的是线性的做法，从左到右扫一遍，要求前一个为后一个加一或减一，但是实现较复杂。后来想到可以直接模拟，找到编号为111 的小朋友向左或向右找，找到一边有答案就记为YES，否则就是NO。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt; using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define DE(...) fprintf(stderr,__VA_ARGS__);#define DEBUG(a) DE(&quot;DEBUG: %d\\n&quot;,a)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)#define ll long long int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125; const int INF=0x3f3f3f,MAXN=200+10; int p[MAXN]; int main() &#123; int t=read(); while(t--) &#123; int n=read(); REP(i,1,n) p[i]=read(); bool flag1=0,flag2=0; int pos; REP(i,1,n) if(p[i]==1) pos=i; int cnt=1; REP(i,1,n-1) &#123; int now=(i+pos)%n; if(now==0) now=n; cnt++; if(p[now]!=cnt) flag1=1; //cout&lt;&lt;now&lt;&lt;&quot; &quot;; &#125; //puts(&quot;&quot;); cnt=n+1; REP(i,1,n-1) &#123; int now=(pos+i+n)%n; if(now==0) now=n; cnt--; if(p[now]!=cnt) flag2=1; &#125; if(!flag1||!flag2) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"模拟","slug":"模拟","permalink":"https://www.micdz.cn/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"暑期学习总结","slug":"summer-vacation","date":"2019-08-12T11:44:38.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/summer-vacation/","link":"","permalink":"https://www.micdz.cn/article/summer-vacation/","excerpt":"暑期所学知识的总结 本文递交已结束。","text":"暑期所学知识的总结 本文递交已结束。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://www.micdz.cn/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"Flyioi离线版","slug":"flyioi-offline","date":"2019-08-12T10:54:35.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/flyioi-offline/","link":"","permalink":"https://www.micdz.cn/article/flyioi-offline/","excerpt":"flyioi离线版是由MicDZ维护的flyioi本地版本。基于uoj前端，部署于github，无后端设计。 Upd2019.12.03 MicDZ已停止维护该项目，请联系ratingeater 项目地址GitHub","text":"flyioi离线版是由MicDZ维护的flyioi本地版本。基于uoj前端，部署于github，无后端设计。 Upd2019.12.03 MicDZ已停止维护该项目，请联系ratingeater 项目地址GitHub","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"https://www.micdz.cn/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"最小生成树算法总结","slug":"minimum-spanning-tree","date":"2019-08-11T15:45:30.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/minimum-spanning-tree/","link":"","permalink":"https://www.micdz.cn/article/minimum-spanning-tree/","excerpt":"最小生成树是最简单的图论算法。 本文递交已结束。","text":"最小生成树是最简单的图论算法。 本文递交已结束。 kruskal kruskal算法是基于贪心的最小生成树算法。其算法实现流程如下：将边按照边权从小到大排序，从最小的边开始加入生成树，如果当前边的两端点未联通则可以加入生成树不会形成环，直至加到第n−1n-1n−1 条边为止。算法的复杂度决定于排序与并查集大致为mlog⁡mm\\log mmlogm。 证明kruskal的正确性在课堂上没有严格说明（？），参考《算法竞赛进阶指南》证明方法如下： 定理：任意一棵最小生成树一定包含无向图中权值最小的边。 证明：假设有一棵在无向图GGG中的最小生成树不包含权值最小的边。设边e(u,v,w)e(u,v,w)e(u,v,w)为该无向图中权值最小的边。将eee加入树种则会和树上从uuu 到vvv的路径一起构成一个环，且环上其他边的权都比www大，那么eee可以替代任何其他边形成一棵比当前最小更小的生成树，产生矛盾，则假设不成立，原命题成立。 有了上述的定理推导即可得出kruskal的正确性。 Prim Prim算法也基于上面的定理，不同的是其思路由向生成树中加边变为加点，实现流程类似于Dijkstra算法。每次选择距离已确定生成树最短的点加入生成树，用堆优化可以实现Θ(mlog⁡n)\\Theta(m\\log n)Θ(mlogn)的复杂度。 考虑kruskal算法与Prim算法的区别，Prim在处理稠密图时效率高于kruskal算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=400000+10;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int head[MAXN],_next[MAXN],to[MAXN],weigh[MAXN],cnt,dis[MAXN];bool vis[MAXN];void addedge(int u,int v,int w) &#123; cnt++; _next[cnt]=head[u]; head[u]=cnt; to[cnt]=v; weigh[cnt]=w;&#125;typedef pair&lt;int,int&gt; p;priority_queue &lt;p,vector&lt;p&gt;,greater&lt;p&gt; &gt; q;int main() &#123; //freopen(&quot;test.in&quot;,&quot;r&quot;,stdin); int n=read(),m=read(); REP(i,1,m) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; memset(dis,127,sizeof(dis)); dis[1]=0; q.push(make_pair(0,1)); int tot=0,sum=0; while(!q.empty()&amp;&amp;tot&lt;n) &#123; int d=q.top().first,u=q.top().second; //puts(&quot;in&quot;); q.pop(); if(vis[u]) continue; tot++; sum+=d; vis[u]=1; for(int i=head[u]; i; i=_next[i]) if(weigh[i]&lt;dis[to[i]]) &#123; dis[to[i]]=weigh[i]; q.push(make_pair(dis[to[i]],to[i])); &#125; &#125; printf(&quot;%d\\n&quot;,sum); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://www.micdz.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://www.micdz.cn/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"求割点、割边、强连通分量总结","slug":"tarjan","date":"2019-08-11T15:45:30.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/tarjan/","link":"","permalink":"https://www.micdz.cn/article/tarjan/","excerpt":"tarjan求图的联通性问题是一种高效的模板化方法。其依赖于dfndfndfn与lowlowlow求解，十分巧妙。 kosaraju依赖更加巧妙的性质，证明略为复杂。 本文递交已结束。","text":"tarjan求图的联通性问题是一种高效的模板化方法。其依赖于dfndfndfn与lowlowlow求解，十分巧妙。 kosaraju依赖更加巧妙的性质，证明略为复杂。 本文递交已结束。 tarjan求解 对于一棵树树，其各节点时间戳如下图： 研究树的联通性问题是没有意义的，除了时间戳（dfndfndfn）外，另外引入一个追溯值（lowlowlow）记录对于一个节点uuu其本身及其深度优先搜索子树所有点可以回到的最小的时间戳，对于一个普通的有向图其深度优先搜索时间戳[]及追溯值() 为： 割点判定法则：在无向图中，当某一点uuu，其任意一个出边所连的点vvv 当且仅当满足dfn[u]&lt;=low[v]dfn[u]&lt;=low[v]dfn[u]&lt;=low[v]（该点有一个子树中所有的点都没有办法追溯回uuu 的祖先，则当将uuu 删除时该子树会断开）时uuu 为该图的割点，特别的若uuu 为根节点，只要有超过两个子节点即为割点。 割边判定法则：在无向图中，与求解割点类似的在深度优先搜索生成树中某一条边(u,v)(u,v)(u,v)，当且仅当dfn[u]&lt;low[v]dfn[u]&lt;low[v]dfn[u]&lt;low[v]时，该边为割边。 强连通分量的求解方法：在有向图的深度优先搜索生成树中若存在某一点uuu当满足dfn[u]=low[u]dfn[u]=low[u]dfn[u]=low[u]时，uuu 与其子树中所有的点都在同一个强连通分量中。利用栈记录下搜索顺序，当找到一个节点uuu 时从栈顶到栈中的uuu之间的所有元素即为其子树，它们在同一个强连通分量中。 Kosaraju求强连通分量 谭老师在课堂上详细地证明了Kosaraju的正确性，证明思路较为复杂。Kosaraju与Tarjan思路相类似，首先在图中任选一个节点的作为起点开始dfs，按照退出的顺序给节点编号就是搜索森林的后序序列。再每次选择未访问的标号最大的点进行搜索，其搜索树的节点都在同一个强连通分量中。 证明是比较复杂的。首先对于第一次搜索，编号小的到编号大的一定存在一条直接路径，除非它们不在同一棵树中。将图求逆后，编号小的一定不能再通过原来的路径到达编号大的，那么从编号大的节点开始dfs一遍，能够到达的节点在原图一定至少存在两条路径是让它们互相相连的。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"tarjan","slug":"tarjan","permalink":"https://www.micdz.cn/tags/tarjan/"}]},{"title":"最近公共祖先的倍增求法总结","slug":"LCA-new","date":"2019-08-11T15:45:30.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/LCA-new/","link":"","permalink":"https://www.micdz.cn/article/LCA-new/","excerpt":"高效求解最近公共祖先的价值是巨大的。其中最简单的应用就是求解树任意两点之间的距离。 本文递交已结束。","text":"高效求解最近公共祖先的价值是巨大的。其中最简单的应用就是求解树任意两点之间的距离。 本文递交已结束。 对于要求解节点uuu与节点vvv的最近公共祖先，朴素的思想是将uuu 与vvv 同时向上跳，并标记跳到过的点如果当任意一个点第一次跳到某一个被标记过的点时即为这两点的最近公共祖先。当树退化成链时求解的复杂度变为了 O(n)O(n)O(n) 。利用倍增思想优化是十分简单的，“即将uuu、vvv成倍地向上跳”。但是为了方便从上向下跳更为简单。首先将两点调至同一高度，由于知道高度差，这一步只需要对高度差进行二进制拆分即可。然后，将两点向上跳2log⁡n2^{\\log n}2logn（即为一个极大的值，超过根就记为根）步，此时两点所到之处一定是相同，那么则说明跳多了，则将两点向上跳2log⁡n−12^{\\log n-1}2logn−1 步，此时如果两节点不在同一位置这说明它们的公共祖先在它们原来位置的2log⁡n−12^{\\log n-1}2logn−1 与2log⁡n2^{\\log n}2logn之间。重复上述过程则可以在Θ(log⁡n)\\Theta(\\log n)Θ(logn)的级别下求出最近公共祖先。考虑上述算法的过程，只有在所到之点不同时两点才会向上跳即更新起点的位置，那么算法最后一定会停留在两点起点不相同但向上跳202^020所到之点就相同的位置，即为最近公共祖先的儿子，最后返回答案时返回其父亲即可。 还有一种效率极高但空间复杂度为O(n2)O(n^2)O(n2)的最近公共祖先的算法。大概的思路是从叶子节点开始灌水，但空间复杂度极高几乎没用。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"LCA","slug":"LCA","permalink":"https://www.micdz.cn/tags/LCA/"}]},{"title":"最短路径算法总结","slug":"shortest-path","date":"2019-08-11T15:45:30.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/shortest-path/","link":"","permalink":"https://www.micdz.cn/article/shortest-path/","excerpt":"单源最短路径又分为单源单汇与单源多汇问题，它们的复杂度几乎相同那么只考虑单源多汇问题。 本文递交已结束。","text":"单源最短路径又分为单源单汇与单源多汇问题，它们的复杂度几乎相同那么只考虑单源多汇问题。 本文递交已结束。 Dijkstra算法是一种基于贪心的最短路径算法，通过堆优化后可以实现Θ(mlog⁡n)\\Theta(m\\log n)Θ(mlogn) 的复杂度。其算法实现流程如下：首先从起点出发，更新与起点相连所有点的dist 值为起点到该点的距离，再选定全局中dist 值最小的点重复上述过程，等到所有点都被作为起点拓展过一遍时算法结束。特别的该算法无法解决存在负边权的图的最短路问题。 该算法的证明也是显然的。 证明：对于上面的这一张图,若设定1 为起点，首先会将3、5、6节点更新，此时全局最小则为6号节点，可以证明在不存在负边权的情况下，起点到6 的最短路径一定是从1 到6，这是因为任何其他到达6 的路径都需要经过非1到6这条边，那么到达6 时的距离一定会大于直接从1到6。同理从6 再更新时也是如此。更严谨的来说是，全局最小的dist值的点的最短路径是确定的，再利用该已确定最短路径的点进行拓展一定可确定另一个或在此之前的已确定的比通过该最小点拓展更小的点为下一次的出发点，该出发点的最短路径也是确定了的。 SPFA是对Bellman-Ford算法的队列优化版本，其复杂度为Θ(km)\\Theta(km)Θ(km)，在段凡丁论文中提出kkk是一个极小的常数是错误的，该算法的最坏复杂度为Θ(nm)\\Theta(nm)Θ(nm)，不如Dijkstra算法稳定，但对于一般的图而言（例如USACO热浪），SPFA效率是Dijkstra 的许多倍。其算法思路类似于Bellman-Ford算法，记录通过几次中转到达某地的最优情况，思路类似于BFS。队列优化后的代码非常好写。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://www.micdz.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"搜索的压缩方法总结","slug":"search-compress","date":"2019-08-11T15:40:01.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/search-compress/","link":"","permalink":"https://www.micdz.cn/article/search-compress/","excerpt":"搜索的压缩是搜索中的常用技巧，能够使搜索更便于保存状态、查询状态。 本文递交已结束。","text":"搜索的压缩是搜索中的常用技巧，能够使搜索更便于保存状态、查询状态。 本文递交已结束。 进制压缩法 我的黑白棋游戏二进制压缩的代码如下： 123456int binary_hash(char str[][]) &#123; int ans=0; REP(i,1,4) REP(j,1,4) ans=(ans&lt;&lt;1)+str[i][j]-&#x27;0&#x27;; return ans;&#125; 二进制压缩适用于对于状态的每一个位置有且仅有两种可能值的情况，否则需要多进制的压缩方式。其支持Θ(1)\\Theta(1)Θ(1)的单位置查询、Θ(n)\\Theta(n)Θ(n)的压缩。 康托展开压缩法 康托展开的公式如下： X=∑i=1nai∏j=1i−1j=an(n−1)!+an−1(n−2)!+...+a1∗0!\\begin{aligned} X&amp;=\\sum_{i=1}^na_i\\prod_{j=1}^{i-1}j\\\\ &amp;=a_n(n-1)!+a_{n-1}(n-2)!+...+a_1*0! \\end{aligned} X​=i=1∑n​ai​j=1∏i−1​j=an​(n−1)!+an−1​(n−2)!+...+a1​∗0!​ 其中，aia_iai​表示的是表示原数的第i 位在当前未出现的元素中是排在第几个。 康拓展开求出的是一个序列在对应长度序列的全排列中由小到大的顺序。求解某一序列的康托序与通过康托序逆推排列都是可以完成的。但是康托展开的朴素复杂度为Θ(n2)\\Theta(n^2)Θ(n2)，用log⁡\\loglog的数据结构优化可以实现Θ(nlog⁡n)\\Theta(n\\log n)Θ(nlogn) 但是实现过于复杂，逆康托展开的复杂度则更高，优化更为复杂。 哈希压缩法 还有另一种高效率的状压方法是哈希，它能够适用于各种类型的序列，例如字符串、矩阵，不受限于状态的位置及可能情况。但是无法做到通过散列值逆推出原序列，只能保证在大概率下每个序列有且仅有一个对应散列值。所以哈希更广泛应用于去重与互联网加密等环节中。哈希仍可能存在冲突即多个序列对应一个散列值的情况，但是发生错误的概率极低。无错哈希对内存的占用较高也不常用。 哈希的代码如下： 1234567int hash(char s[]) &#123; int len=strlen(s); int ans=0; REP(i,0,len-1) ans=(ans*base+s[i])%mod+prime; return ans;&#125; 朴素哈希的复杂度为Θ(len)\\Theta(len)Θ(len)，STLmap映射的复杂度要再乘上一个log⁡\\loglog的级别。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://www.micdz.cn/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"拓展欧几里得","slug":"ex-euclid","date":"2019-08-03T13:42:05.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/ex-euclid/","link":"","permalink":"https://www.micdz.cn/article/ex-euclid/","excerpt":"数论是学习OI的自闭之路。QAQ","text":"数论是学习OI的自闭之路。QAQ 问题如下： 求不定方程的整数解 ax+by=gcd⁡(a,b)ax+by=\\gcd(a,b) ax+by=gcd(a,b) 的解。 通过欧几里得原理： gcd⁡(a,b)=gcd⁡(b,a%b)\\gcd(a,b)=\\gcd(b,a\\%b) gcd(a,b)=gcd(b,a%b) 那么原式可化为： bx′+a%by′=gcd(b,a%b)bx&#x27;+a\\%by&#x27;=gcd(b,a\\%b) bx′+a%by′=gcd(b,a%b) 那么只需求出xxx与x′x&#x27;x′，yyy与y′y&#x27;y′的关系即可： bx′+a%by′=gcd(b,a%b)=gcd⁡(a,b)=ax+by\\begin{aligned} bx&#x27;+a\\%by&#x27;&amp;=gcd(b,a\\%b)\\\\=\\gcd(a,b)&amp;=ax+by\\\\ \\end{aligned} bx′+a%by′=gcd(a,b)​=gcd(b,a%b)=ax+by​ 将含aaa与含bbb的合并 bx′+a%by′=ax+bybx′+ay′−⌊ab⌋b×y′=ax+byb(x′−y−⌊ab⌋×y′)+a(y′−x)=0\\begin{aligned} &amp;bx&#x27;+a\\%by&#x27;=ax+by\\\\ &amp;bx&#x27;+ay&#x27;-\\lfloor\\frac{a}{b}\\rfloor b\\times y&#x27;=ax+by\\\\ &amp;b(x&#x27;-y-\\lfloor\\frac{a}{b}\\rfloor\\times y&#x27;)+a(y&#x27;-x)=0 \\end{aligned} ​bx′+a%by′=ax+bybx′+ay′−⌊ba​⌋b×y′=ax+byb(x′−y−⌊ba​⌋×y′)+a(y′−x)=0​ 已知该式恒成立，则： x=y′y=x′−⌊ab⌋×y′\\begin{aligned} x&amp;=y&#x27;\\\\ y&amp;=x&#x27;-\\lfloor\\frac{a}{b}\\rfloor\\times y&#x27; \\end{aligned} xy​=y′=x′−⌊ba​⌋×y′​ 再利用辗转相除的函数递归计算xxx，yyy即可。 代码如下： 12345678910int x,y;int exgcd(int a,int b) &#123; if(b==0) &#123;x=1,y=0;return a;&#125; int g=exgcd(b,a%b); int oldx=x,oldy=y; x=oldy; y=oldx-a/b*oldy; return g;&#125; 这里需要注意的是，递归的边界为x=1,y=0x=1,y=0x=1,y=0时的一组特解。 那么将此式拓展为一般结论，即求解： ax+by=cax+by=c ax+by=c 首先讨论有无解，当gcd⁡(a,b)∤c\\gcd(a,b)\\nmid cgcd(a,b)∤c一定无解，这里就不给出证明。我们另k=cgcd⁡(a,b)k=\\frac{c}{\\gcd(a,b)}k=gcd(a,b)c​： ax′k+by′k=gcd⁡(a,b)×k=cax&#x27;k+by&#x27;k=\\gcd(a,b)\\times k=c ax′k+by′k=gcd(a,b)×k=c 就得到了x=x′kx=x&#x27;kx=x′k，y=y′ky=y&#x27;ky=y′k。 如果要求xxx非负且最小，另t=bgcd⁡(a,b)t=\\frac{b}{\\gcd(a,b)}t=gcd(a,b)b​，则(x%t+t)%t(x\\%t+t)\\%t(x%t+t)%t就是xxx的最小非负解。加ttt主要是为了处理负数的问题。 有关例题：","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"【HAOI2006】Travel 题解","slug":"HAOI2006-travel","date":"2019-07-29T10:50:23.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/HAOI2006-travel/","link":"","permalink":"https://www.micdz.cn/article/HAOI2006-travel/","excerpt":"HAOI","text":"HAOI 题目大意 给定一张图，求从s到t经过边权最大与最小之比最小值。 核心思路 因为要保证sss、ttt联通，所以按照普通的bfs思路是行不通的，会导致更新错乱的问题，因为可能到这个点的所经过最大边的最小值的路径与所经过最小边的最大值的路径是不同的，但是似乎有大佬写出了此题的bfs解法。 那么考虑最小生成树的算法。考虑如下问题，如果固定图中的最小边，那么存在此边的使sss、ttt联通的路径的最大边最小值一定是固定的。 那么在这固定的含有固定的最小边的使sss、ttt联通的路径的最大边一定是含有此固定边的使sss、ttt联通的图中中最长边最短的。 那么对于每一条边，向其中加入比它长的边，直至联通，再用图中最长边与最短边更新答案即可。 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int MAXN=500+10,MAXM=50000+10;struct edge &#123; int u,v,w;&#125;a[MAXM];bool cmp(edge a,edge b) &#123; return a.w&lt;b.w;&#125;int fa[MAXN];int find(int x) &#123; if(fa[x]==x) return x; return fa[x]=find(fa[x]);&#125;int link(int x,int y) &#123; fa[find(x)]=find(y);&#125;int main() &#123; int n=read(),m=read(); REP(i,1,n) fa[i]=i; REP(i,1,m) &#123; a[i].u=read(); a[i].v=read(); a[i].w=read(); link(a[i].u,a[i].v); &#125; int s=read(),t=read(); if(find(s)!=find(t)) &#123;puts(&quot;IMPOSSIBLE&quot;);return 0;&#125; sort(a+1,a+1+m,cmp); int maxx=0,minn=0; REP(i,1,m) &#123; REP(j,1,n) fa[j]=j; int now=0; for(now=i; now&lt;=m; now++) &#123; // now=j; if(find(a[now].u)==find(a[now].v)) continue; link(a[now].u,a[now].v); if(find(s)==find(t)) break; &#125; if(find(s)!=find(t)) break; if(maxx*a[i].w&gt;=a[now].w*minn) maxx=a[now].w,minn=a[i].w; &#125; int g=__gcd(maxx,minn); if(minn/g!=1) printf(&quot;%d/%d\\n&quot;,maxx/g,minn/g); else printf(&quot;%d\\n&quot;,maxx/g); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"【CJOJ】 甜点","slug":"Z-solution","date":"2019-07-23T22:11:45.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/Z-solution/","link":"","permalink":"https://www.micdz.cn/article/Z-solution/","excerpt":"CJ NOIp模拟赛动态规划。","text":"CJ NOIp模拟赛动态规划。 题目描述 小 z 准备举办一个比赛。他需要提供一些甜点给参赛者来补充能量。每种甜品有一定的能量 tit_iti​和大小 uiu_iui​，且每种甜点最多有viv_ivi​个。小 z 准备用箱子来包装甜点。箱子可以容纳一定体积的甜点且需要一定的费用。小 z有一种魔法，可以将一个甜点分成多份装在箱子里，最后再合在一起（但合成之后必须是完 整的一个）。小 z 想知道准备能量至少为 P 的甜点的最小大小和最少需要多少费用来购买箱子，如果最少费用超过小 z 所拥有的钱数 k 则输出FAIL。 核心思想 经过分析，对于糖的能量与箱子的容量都为完全背包。只需要对糖和箱子做两次完全背包即可。这里有一个问题是，我们并不知道糖的最大体积，我们可以假定其为2000（由具体题目数据范围而定），然后在dp[1−2000]dp[1-2000]dp[1−2000]中找到第一个大于所需能量的最小糖果体积。再将此数值记录下来用于下次的箱子的完全背包中。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//考场代码略丑#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define DREP(i,e,s) for(register ll i=e; i&gt;=s; i--)#define REP(i,e,s) for(register ll i=e; i&lt;=s; i++)#define file(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)ll read() &#123; ll x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;) &#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const ll MAXN=6000+10,INF=0x3f3f3f3f3f3f3f3f;ll w[MAXN][2],v[MAXN][2],l[MAXN][2],dp[MAXN*1000];int main() &#123; file(&quot;z&quot;); ll n=read(),m=n,t=20000,p=read(),q=p,power_need=read(),money_have=read(); REP(i,1,n) &#123; v[i][0]=read(); w[i][0]=read(); l[i][0]=read(); &#125; REP(i,1,p) &#123; v[i][1]=read(); w[i][1]=read(); l[i][1]=read(); &#125; REP(i,1,n) &#123; int maxx=log(l[i][0])/log(2); REP(j,1,maxx-1) &#123; m++; w[m][0]=(1&lt;&lt;j)*w[i][0]; v[m][0]=(1&lt;&lt;j)*v[i][0]; //cout&lt;&lt;w[m]&lt;&lt;&quot; &quot;&lt;&lt;v[m]&lt;&lt;endl; l[i][0]-=(1&lt;&lt;j); &#125; l[i][0]-=1; if(l[i][0]&gt;0) &#123; m++; w[m][0]=l[i][0]*w[i][0]; v[m][0]=l[i][0]*v[i][0]; //cout&lt;&lt;w[m]&lt;&lt;&quot; &quot;&lt;&lt;v[m]&lt;&lt;endl; &#125; &#125;//用到了log的优化 REP(i,1,m) DREP(j,t,w[i][0]) dp[j]=max(dp[j],dp[j-w[i][0]]+v[i][0]); ll ans=-INF; REP(i,1,t) if(dp[i]&gt;=power_need) &#123;printf(&quot;%d\\n&quot;,i);ans=i;break;&#125; int qerwer=ans; t=20000; n=m=p; REP(i,1,n) &#123; int maxx=log(l[i][1])/log(2); REP(j,1,maxx-1) &#123; m++; w[m][1]=(1&lt;&lt;j)*w[i][1]; v[m][1]=(1&lt;&lt;j)*v[i][1]; //cout&lt;&lt;v[m]&lt;&lt;&quot; &quot;&lt;&lt;w[m]&lt;&lt;endl; l[i][1]-=(1&lt;&lt;j); &#125; l[i][1]-=1; if(l[i][1]&gt;0) &#123; m++; w[m][1]=l[i][1]*w[i][1]; v[m][1]=l[i][1]*v[i][1]; //cout&lt;&lt;v[m]&lt;&lt;&quot; &quot;&lt;&lt;w[m]&lt;&lt;endl; &#125; &#125; memset(dp,0,sizeof(dp)); REP(i,1,m) DREP(j,t,w[i][1]) dp[j]=max(dp[j],dp[j-w[i][1]]+v[i][1]); REP(i,1,t) &#123; //printf(&quot;%d &quot;,dp[i]); if(dp[i]&gt;=qerwer) &#123;ans=i;break;&#125; &#125; if(ans&gt;money_have) puts(&quot;FAIL&quot;); else printf(&quot;%d\\n&quot;,ans);&#125; 此题的自测数据onedrive。可能需要科学上网。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.micdz.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包","slug":"背包","permalink":"https://www.micdz.cn/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"【UVA11538】Chess Queen题解","slug":"UVA11538-solution","date":"2019-07-23T22:06:30.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/UVA11538-solution/","link":"","permalink":"https://www.micdz.cn/article/UVA11538-solution/","excerpt":"此题有Θ(T)\\Theta(T)Θ(T)的做法，感谢lrc大佬讲解","text":"此题有Θ(T)\\Theta(T)Θ(T)的做法，感谢lrc大佬讲解 已经得到了 ans1=Cm1An2=nm(n−1)ans_1=C_m^1A_n^2=nm(n-1) ans1​=Cm1​An2​=nm(n−1) ans2=Cn1Am2=nm(m−1)ans_2=C_n^1A_m^2=nm(m-1) ans2​=Cn1​Am2​=nm(m−1) ans1ans_1ans1​与ans2ans_2ans2​为在同一行与同一列互相攻击的皇后数 ans3ans_3ans3​为在同一斜列的互相攻击皇后数 显然 ans3=2×[A22+A32+...+An2×(m−n+1)+...+A32+A22]ans_3=2\\times[A_2^2+A_3^2+...+A_n^2\\times(m-n+1)+...+A_3^2+A_2^2] ans3​=2×[A22​+A32​+...+An2​×(m−n+1)+...+A32​+A22​] 如何化简？将此式展开 ans3=[1×2+2×3+...+(n−1)×n]×4+2n(n−1)(m−n)ans_3=[1\\times2+2\\times3+...+(n-1)\\times n]\\times4+2n(n-1)(m-n) ans3​=[1×2+2×3+...+(n−1)×n]×4+2n(n−1)(m−n) 前半部分就像小学奥数中的通项求和问题了 ans3=∑i=1n−1i(i+1)×4+2n(n−1)(m−n)ans_3=\\sum_{i=1}^{n-1}{i(i+1)}\\times 4+2n(n-1)(m-n) ans3​=i=1∑n−1​i(i+1)×4+2n(n−1)(m−n) =∑i=1n−1i2×4+∑i=1n−1×4+2n(n−1)(m−n)=\\sum_{i=1}^{n-1}{i^2} \\times 4+ \\sum_{i=1}^{n-1} \\times 4+2n(n-1)(m-n) =i=1∑n−1​i2×4+i=1∑n−1​×4+2n(n−1)(m−n) 由∑i=1ni2=n(n+1)(2n+1)6\\sum_{i=1}^ni^2=\\frac{n(n+1)(2n+1)}{6}∑i=1n​i2=6n(n+1)(2n+1)​得 ans3=[n(n−1)(2n−1)6+n(n−1)2]×4+2n(n−1)(m−n)ans_3=[\\frac{n(n-1)(2n-1)}{6}+\\frac{n(n-1)}{2}]\\times4+2n(n-1)(m-n) ans3​=[6n(n−1)(2n−1)​+2n(n−1)​]×4+2n(n−1)(m−n) =2n(n−1)(2n−1)3+2n(n−1)(m−n)=\\frac {2n(n-1)(2n-1)}{3}+2n(n-1)(m-n) =32n(n−1)(2n−1)​+2n(n−1)(m−n) 最后再把ans1ans_1ans1​，ans2ans_2ans2​，ans3ans_3ans3​加起来即可 Ps：此题不能通过分析边角与非边角位置的攻击数来统计答案，这样会使解答更为复杂。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"香港、澳门、马尼拉、杜马盖地游玩攻略","slug":"php-2019","date":"2019-02-09T12:43:51.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/php-2019/","link":"","permalink":"https://www.micdz.cn/article/php-2019/","excerpt":"MicDZ退役后的第一个寒假去菲律宾好好放松了一把。途径了香港、马尼拉、澳门等城市。今天在此处总结一些经验，形成一篇攻略。","text":"MicDZ退役后的第一个寒假去菲律宾好好放松了一把。途径了香港、马尼拉、澳门等城市。今天在此处总结一些经验，形成一篇攻略。 香港 高铁 我从长沙出发，乘坐复兴号动车组到达香港西九龙。香港西九龙的入境流程十分繁琐。出站台以后首先出中国境，这里常驻只有两个窗口，排队要许久，下车一定要用跑的。注意，从香港西九龙出境如果是到香港转机的话用护照+机票订单就好了。过了中国境入香港境的时候就要填写一个单子，但去香港旅游的不需要，车站有普通话的广播提醒。在你填单子的时候会有几名警卫来抽查机票、行李。与西九龙高铁站相连的有两座地铁站，走路都要蛮久，注意选择。西九龙没有外币找兑服务，记得提前换好必要交通费用。市内基本可以用在线支付，按实时汇率来，不必担心。 市内交通 香港市区内有许多条机场快线，我住在凯德酒店，旁边就有机场快线21A，40分钟到机场。坐公车或地铁20分钟就可以到维多利亚港。可以说这个位置是十分方便的。在香港可以使用谷歌服务，记得在酒店好好享（xuan）受（yao）。 餐饮 香港的早餐十分丰富，价格都不菲，人均50人民币左右。大部分饭店、超市都支持了微信支付（WeChat pay）和支付宝（Ali pay）。微信偶尔有一些活动记得留意。 香港国际机场 香港国际机场我到过三遍，两次转机，一次出发。赤鱲角机场有两个航站楼、两条跑道。两座航站楼之间有“地铁”相连。gate105以上的都在小航站楼，小航站楼只能从大航站楼坐地铁到达并且小航站楼里没有什么商店、餐厅。想要吃饭的只能在大航站楼解决。记得提前动身，地铁每十分钟一趟。国际航班（香港机场全是国际航班）提前15分钟登机，你至少需要提前30分钟从大航站楼出发。我们提前20分钟结果全机场通报名字finalcall。如果你到的比较早，你可以到大航站楼的gate旁边有“免费互联网服务”，这里有苹果iMac、华硕、华为等公司的电脑。使用的人非常少，足够你嗨一把。香港国际机场的延误量比较小，基本可以放心安排2h以后的航班转机，1h以内最好不要考虑。 购物 港币的汇率在0.84左右，在香港购物是一件十分明智的选择。以Apple为例，Apple China定价与Apple HK 在数值上的定价是一致的但是港币要比人民币便宜不少。购置一台iPhoneXs Max可以便宜1000-2000元人民币。 语言 香港大部分人会粤语，在这其中有少部分人会普通话。如果你不会粤语但和你交流的人只会粤语，你最好和他直接说英语，香港人的英语还是蛮靠得住的。 马尼拉 马尼拉国际机场 我在马尼拉只在机场呆过，具体原因是马尼拉的治安有一点问题，马尼拉机场是全市最安全的地方。尽管如此，还是让人充斥着不安。 马尼拉国际机场没有国际转国内的transfer，你必须在马尼拉入海关。马尼拉机场的到达层与出发层在同一位置。千万不要搞混了你是要出机场还是要转机。如果你买的是联程机票，你可以直接凭借机票进入候机楼，但你仍然需要出马尼拉机场。所以你从马尼拉转机的流程可以这样概括： 入菲律宾境-&gt;出马尼拉机场-&gt;入马尼拉机场-&gt;安检-&gt;候机。 而国内（例如香港）的机场一般是这样： 入香港境-&gt;候机 但是，如果你没有买联程机票，因为出发层与到达层是同一层，那么这个流程将会更繁琐。 入菲律宾境-&gt;出马尼拉机场-&gt;安检-&gt;入马尼拉机场-&gt;等待登机牌窗口更新-&gt;领取登机牌-&gt;安检-&gt;候机 彻底对马尼拉机场无语。😓我们晕头转向提着大包小包问了无数工作人员，花费了整整1.5小时从到达层跑到隔壁候机楼。 马尼拉机场的餐饮比较贵，我们吃的一个日系面粉花了500人民币7个人。但是味道很中国，甚至怀疑是中国人开的日料店。 马尼拉机场延误很严重，经过两次乘机我大概明白了它延误的原因。飞机在taxiing的时候，飞机并不会立即开始与塔台确定是否可以起飞，这将导致飞机滑行到了跑道上再花费5分钟以上的时间与塔台确定。每架飞机5分钟，后面的航班自然就延误了。香港国际机场与之不同的是，每一名空管对应1-2架飞机，实时与飞行员确定跑道情况及排队情况，这就创造了5分钟一飞机起飞、一飞机降落的奇迹。 马尼拉的夜景十分漂亮，起飞建议坐在左侧的位置，这样在起飞之后可以低空直接看到错综复杂的城市网络，坐在右侧可能只能看到茫茫大海。 马尼拉国际机场有三家航空公司，分别是宿务航空公司(Cebu)、菲律宾航空公司(PHP)、亚洲航空公司(AS)注意代号的不同，三家航空公司有不同的航站楼，但也不固定。我在马尼拉坐两次飞机，两次都改了登记口，其中一次还改了航站楼，幸好到的早，但还是全机场通报了名字finalcall。 杜马盖地 杜马盖地是东内格罗斯省的省会，有全亚洲最古老的大学。 杜马盖地机场 这是一个非常小的机场，全机场只有一个塔台、一个跑道和两个帐篷。这两个帐篷构建起了到达处和出发处。菲律宾人非常友好，在下飞机时还给每个人发了一把伞。 澳门 至于为什么选择回程到澳门转机，最主要的原因是这架航班太便宜了。某程只要300人民币，这比我们回来的高铁票还要便宜许多。 澳门国际机场 澳门是出了名的小，但是这机场也实在是把空间利用到了极限，跑道是填出来的就不说了，就论着陆之后从跑道滑行到航站楼就花了25分钟。澳门国际机场又没有引客闸，全程摆渡车，工作人员极其冷漠爱理不理还一顿教训。到了国际到达处的时候，就被澳门的冷空调震撼了，室外温度20+，市内估计只有17左右。怕冷的我立马穿上了羽绒服。入境有大约5个柜台，不要担心排队的问题，15分钟应该足够了。持护照入境会有一张小小的纸片，告诉你一些注意事项，别搞丢了，出境可能会用到。 交通 澳门的士费用十分昂贵，并且不得超载，在国内一辆小轿车载3个大人4个小孩绰绰有余，但在澳门不行。我们从机场打的到酒店足足花了100人民币。澳门的公交系统十分发达，基本可以转一次车到全市。但是澳门没有地铁，只有动车。但是动车只有一条线路。贯穿了澳门半岛以及凼仔（澳门本地的“氹”为异体字）岛东部，终点到科技大学。港珠澳大桥好像不准游客出。 购物 澳门的苹果可以说太便宜了，定价在数值上比大陆贵100，但澳门元要比港币还便宜一点，低点甚至可以到0.75左右。这个时机去买还不是最好的时机。我们一行有人买了iPhoneXs Max256GB，花费9000人民币左右。澳门的教育优惠也比较大但是必须本地学生才能享受。 我们在watson买了12罐奶粉，比大陆便宜50/罐的样子，其实没便宜多少，但是他们说澳门的东西比大陆真一些。 未完待续。。。","categories":[{"name":"Others","slug":"Others","permalink":"https://www.micdz.cn/categories/Others/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.micdz.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"基础不等式","slug":"basic-inequalities-problems","date":"2018-12-30T16:34:00.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/basic-inequalities-problems/","link":"","permalink":"https://www.micdz.cn/article/basic-inequalities-problems/","excerpt":"这里将会持续添加一些基础的不等式定理、题目。","text":"这里将会持续添加一些基础的不等式定理、题目。 Basic Inequalities Theorem1. 1 xy≥2xyxy\\geq2\\sqrt{xy}xy≥2xy​. x,y∈R+x,y\\in \\R ^+x,y∈R+ Proof (x−y)2≥0x2−2xy+y2≥0x2+2xy+y2≥4xy(x+y)2≥4xyx+y≥2xy⇔xy≤x+y2Equalitiy occurs if and only if x=y.\\begin{aligned} (x-y)^2&amp;\\geq0\\\\ x^2-2xy+y^2&amp;\\geq0\\\\ x^2+2xy+y^2&amp;\\geq4xy\\\\ (x+y)^2&amp;\\geq4xy\\\\ x+y&amp;\\geq2\\sqrt{xy}\\\\ \\Leftrightarrow xy&amp;\\leq\\frac{x+y}{2}\\\\ Equalitiy\\ \\ occurs\\ \\ if\\ \\ and\\ \\ only\\ \\ if\\ \\ x=y. \\end{aligned} (x−y)2x2−2xy+y2x2+2xy+y2(x+y)2x+y⇔xyEqualitiy occurs if and only if x=y.​≥0≥0≥4xy≥4xy≥2xy​≤2x+y​​ Exercise1. 1 Use Theorem1. 1 to solve this problem. Let 0&lt;x&lt;40&lt;x&lt;40&lt;x&lt;4 . Prove the inequality: x(8−2x)≤8x(8-2x)\\leq8x(8−2x)≤8 . Solution 2x+(8−2x)=8x(8−2x)=12[2x(8−2x)]≤12(2x−8−2x2)2=8\\begin{aligned} 2x+(8-2x)=8\\\\ x(8-2x)=\\frac{1}{2}[2x(8-2x)]\\leq\\frac{1}{2}(\\frac{2x-8-2x}{2})^2=8 \\end{aligned} 2x+(8−2x)=8x(8−2x)=21​[2x(8−2x)]≤21​(22x−8−2x​)2=8​ Exercise1.2 Let n∈Rn\\in Rn∈R . Prove the inequality: 1+122+132+...+1n2≤21+\\frac{1}{2^2}+\\frac{1}{3^2}+...+\\frac{1}{n^2}\\leq21+221​+321​+...+n21​≤2 . Solution It’s easy to know: 1a×a≤1a×(a−1).\\frac{1}{a\\times a}\\leq\\frac{1}{a\\times(a-1)}. a×a1​≤a×(a−1)1​. So 1+122+132+...+1n2&lt;1+11×2+12×3+...+1(n−1)×n=1+11−12+12−13+...+1n−1−1n=2−1n&lt;2\\begin{aligned} 1+\\frac{1}{2^2}+\\frac{1}{3^2}+...+\\frac{1}{n^2}&lt;1+\\frac{1}{1\\times2}+\\frac{1}{2\\times3}+...+\\frac{1}{(n-1)\\times n}\\\\ =1+\\frac1 1 -\\frac1 2 +\\frac1 2-\\frac1 3+...+\\frac{1}{n-1}-\\frac{1}{n}=2-\\frac{1}{n}&lt;2 \\end{aligned} 1+221​+321​+...+n21​&lt;1+1×21​+2×31​+...+(n−1)×n1​=1+11​−21​+21​−31​+...+n−11​−n1​=2−n1​&lt;2​","categories":[{"name":"Math","slug":"Math","permalink":"https://www.micdz.cn/categories/Math/"}],"tags":[{"name":"不等式","slug":"不等式","permalink":"https://www.micdz.cn/tags/%E4%B8%8D%E7%AD%89%E5%BC%8F/"}]},{"title":"在Material-X上使用KaTeX","slug":"katex-on-volantis","date":"2018-12-15T19:24:28.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/katex-on-volantis/","link":"","permalink":"https://www.micdz.cn/article/katex-on-volantis/","excerpt":"Upd2019.10.19：以适配新版本的hexo-renderer-markdown-it-plusUpd2019.12.11：一些复杂公式的渲染问题可以在katex.org上进行测试，如果katex.org上无法正常渲染且您的TeX源码无语法错误的话，请与 KaTeX 的开发者联系。 随着Material-X的使用用户越来越多、使用用户的范围越来越广。不少用户被如何在Material-X上渲染公式所困。xaoxuu给出的方案是完美的，你只需要在使用最新的版本下将文章开头加入一行mathjax: true即可，十分简洁，可以渲染绝大部分简单的公式。 注：本文部分素材来自网络，相关插件来源github。","text":"Upd2019.10.19：以适配新版本的hexo-renderer-markdown-it-plusUpd2019.12.11：一些复杂公式的渲染问题可以在katex.org上进行测试，如果katex.org上无法正常渲染且您的TeX源码无语法错误的话，请与 KaTeX 的开发者联系。 随着Material-X的使用用户越来越多、使用用户的范围越来越广。不少用户被如何在Material-X上渲染公式所困。xaoxuu给出的方案是完美的，你只需要在使用最新的版本下将文章开头加入一行mathjax: true即可，十分简洁，可以渲染绝大部分简单的公式。 注：本文部分素材来自网络，相关插件来源github。 存在的问题 至于有一些复杂的公式为什么渲染不了，大概是有几种 LaTeX\\LaTeXLATE​X 的符号与markdown冲突，在渲染时就会转义错误。错误通常会直接导致无法生成。 操作原理 具体的解决方案是卸载掉原来的渲染器，安装一个针对 KaTeX\\KaTeXKATE​X 优化过的渲染器。 这个渲染器包括了 KaTeX\\KaTeXKATE​X 。 具体操作步骤 卸载原有的渲染器，并安装大神的渲染器（基本稳定可靠） 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-markdown-it-plus --save 在根目录的配置文件_config.yml加入 此为历史版本 1234567plugins: - plugin: name: markdown-it-katex enable: true - plugin: name: markdown-it-mark enable: false 此为更新后版本 12345678910111213markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ plugins: - plugin: name: markdown-it-mark enable: false 至此，你在Material-X下就可以成功使用 KaTeX\\KaTeXKATE​X 渲染公式了。 如果失败，尝试继续进行以下操作： 找到/themes/material-x/layout/_partial/head.ejs 在该文件最后加入一行 此为历史版本 1&lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;KaTeX&#x2F;0.7.1&#x2F;katex.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; 此为更新后版本 12345678&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.11.1&#x2F;dist&#x2F;katex.min.css&quot; integrity&#x3D;&quot;sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP&#x2F;+DiW&#x2F;UqRcLbRjq&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt; &lt;!-- The loading of KaTeX is deferred to speed up page rendering --&gt;&lt;script defer src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.11.1&#x2F;dist&#x2F;katex.min.js&quot; integrity&#x3D;&quot;sha384-y23I5Q6l+B6vatafAwxRu&#x2F;0oK&#x2F;79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;&lt;&#x2F;script&gt; &lt;!-- To automatically render math in text elements, include the auto-render extension: --&gt;&lt;script defer src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.11.1&#x2F;dist&#x2F;contrib&#x2F;auto-render.min.js&quot; integrity&#x3D;&quot;sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI&quot; crossorigin&#x3D;&quot;anonymous&quot; onload&#x3D;&quot;renderMathInElement(document.body);&quot;&gt;&lt;&#x2F;script&gt;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://www.micdz.cn/categories/Solutions/"}],"tags":[{"name":"katex","slug":"katex","permalink":"https://www.micdz.cn/tags/katex/"},{"name":"material-x","slug":"material-x","permalink":"https://www.micdz.cn/tags/material-x/"}]},{"title":"中考历史重大事件总结","slug":"history-big-event","date":"2018-11-22T23:21:37.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/history-big-event/","link":"","permalink":"https://www.micdz.cn/article/history-big-event/","excerpt":"本文总结九上的思想解放运动、资产阶级革命、相关的法律文献。","text":"本文总结九上的思想解放运动、资产阶级革命、相关的法律文献。 思想解放运动 思想解放运动 文艺复兴 启蒙运动 时间 14C-17C 18C 性质 是一次资产阶级性质的思想解放、新文化运动 欧洲继文艺复兴以来的第二次思想解放运动。 影响 1. 推动了欧洲文化思想领域的繁荣2. 为资本主义的产生奠定了思想文化基础3. 有力打击了封建神学4. 促进了人类思想的大解放 1. 为法国大革命作了重要理论准备2. 启发了第三等级的反抗 代表人物及其对应思想(作品) 但丁《神曲》，文学三杰达·芬奇《蒙娜丽莎的微笑》、《最后的晚餐》，美术三杰莎士比亚《哈姆雷特》、《罗密欧与朱丽叶》 伏尔泰：反封建专制孟德斯鸠：三权分立卢梭：人民有权推翻违民意的统治者。 资产阶级革命 资产阶级革命 英国革命 美国独立战争 法国大革命 标志 开始：1640年议会重新召开结束：光荣革命 开始：莱克星顿的枪声结束：英国被迫承认美国独立 开始：攻占巴士底狱结束：无明确 过程 查理一世独裁1649年，英国宣布为共和詹姆士二世引发资产阶级反抗废詹姆士二世，迎请女儿及女婿 1776年发表独立宣言萨拉托加大捷是战争的转折点 1789年《人权宣言》路易十六致信呼吁武装干涉法国热月政变，罗伯斯庇尔被送上断头台 性质 1. 是一次民族解放战争2. 也是一次资产阶级革命 影响 1. 英国确立了议会在国家政治生活的最高地位2. 逐渐形成了君主立宪制 国内：推动了美国资本主义的发展、结束了美国殖民地的统治、实现民族独立。国外：刺激欧洲及拉丁美洲的独立 法国大革命摧毁了法国的君主统治，传播了资产阶级自由民主思想。","categories":[{"name":"Others","slug":"Others","permalink":"https://www.micdz.cn/categories/Others/"}],"tags":[{"name":"历史","slug":"历史","permalink":"https://www.micdz.cn/tags/%E5%8E%86%E5%8F%B2/"}]},{"title":"2019年中考政治答题框架","slug":"politics-exam-tricks","date":"2018-11-22T22:26:22.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/politics-exam-tricks/","link":"","permalink":"https://www.micdz.cn/article/politics-exam-tricks/","excerpt":"政治答题框架归纳。有助于快速提高分数。","text":"政治答题框架归纳。有助于快速提高分数。 原因类 题目中出现：原因、为什么、……的必要性？ 现实依据（表述现状问题的句子） 例如：中国科技水平总体上面临创新能力不强、科技发展水平总体不高、科技对社经济增长的贡献率远低于发达国家水平。（科技国情） 理论依据（课本中阐述重要性的句子） 例如：创新是国家综合国力的决定性因素、创新驱动是国家的命运所系。 有利于（分清主体，对国家、社会、个人） 从材料中寻找主体，翻译材料中句子。 怎么做 翻译材料中的措施 分主体回答 辨析题（观点） 完全正确型：判断+为什么+总结。 完全错误型：判断+为什么错误+更正错误+总结 观点片面型： ​ 正误复合型：判断+正确的部分+为什么正确+错误的部分+为什么错误+总结 ​ 条件缺少型：判断+如果……则正确+为什么+如果……则错误+为什么+总结 ​ 观点不完整：判断+需要……+为什么+还需要……+为什么+总结 其中，判断是指直接指出辨析类型，总结是指怎样做。 作用类 题目中出现作用、意义、影响 有利于国家、社会、个人、材料中的其他主体。 图表题 例如以下题为例： 材料给出： 注：中国GDP同美国相比仍有较大差距 从表格中，你发现了什么？ 答： 小学生答题，描述现象 中华人民共和国国内生产总值增长较快。 通过现象看本质 GDP的提高代表中国经济不断发展、综合国力不断提升、国际地位不断提高。 （收入提高代表人民生活水平提升） 对比（中国、发达国家、城乡） 同美国发达国家相比还有一定差距。 注意一些特殊数字 改革开放取得辉煌成就。 感悟类 是什么？为什么？怎么做（分主体回答）？","categories":[{"name":"Others","slug":"Others","permalink":"https://www.micdz.cn/categories/Others/"}],"tags":[{"name":"政治","slug":"政治","permalink":"https://www.micdz.cn/tags/%E6%94%BF%E6%B2%BB/"}]},{"title":"树状数组与逆序对","slug":"ni-xu-dui","date":"2018-11-09T16:10:53.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/ni-xu-dui/","link":"","permalink":"https://www.micdz.cn/article/ni-xu-dui/","excerpt":"在NOIp来之前，赶快奶一口会出逆序对毒瘤数学题，RP++。","text":"在NOIp来之前，赶快奶一口会出逆序对毒瘤数学题，RP++。 在前几年的NOIp的考试中，已经有很久没有出现过与逆序对有关的题目了。但是正因如此，逆序对在这次NOIp出现的几率就大大提高了。 核心思路 计算逆序对可以通过归并排序或桶排+数据结构优化的思路求解。 又因为归并排序的应用范围不广，因此我更倾向于学习桶排+数据结构优化的方法求逆序对。 下面给出一个样例： 11 8 2 1 4 14 2 如果我们以桶排的思路依次存下每一个元素出现的数量，那么我们只需要求出在它之前的比他大的元素数量，最后求和即可。 因此我们可以对原数列离散化成： 11 4 2 1 3 5 2 对于这个数列，例如我们在计算以第4个1为右端点的逆序对的时候，我们只需要统计从第1个到第3个数字中大于1的数的个数。 这里可应用桶排的思想，从左向右扫，将每一个数加入对应的桶中，再用树状数组对小于当前的元素的桶维护前缀和即可。这样动态单点修改，区间查询就成为了树状数组的强项，可以用树状数组优化到log⁡\\loglog级。 完整代码 同样也可以用线段树，这里只有树状数组的代码。 解释见注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 500000+10#define lowbit(x) (x&amp;(-x))#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define ll long longint read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int c[MAXN],temp[MAXN],n;struct edge &#123; int id,num;&#125; a[MAXN];bool cmp(edge q,edge w) &#123; if(q.num==w.num) return q.id&lt;w.id; return q.num&lt;w.num;&#125;//使用stable_sort可以达到同样效果。void add(int x,int v) &#123; while(x&lt;=n) &#123; c[x]+=v; x+=lowbit(x); &#125;&#125;int sum(int x) &#123; int ans=0; while(x) &#123; ans+=c[x]; x-=lowbit(x); &#125; return ans;&#125;int main() &#123; n=read(); REP(i,1,n) &#123; a[i].num=read(); a[i].id=i; &#125; sort(a+1,a+1+n,cmp); //stable_sort(a+1,a+1+n,cmp); REP(i,1,n) temp[a[i].id]=i;//temp存离散化后的值 ll ans=0; REP(i,1,n) &#123; add(temp[i],1);//将temp[i]加1 ans+=i-sum(temp[i]);//i为在这之前的数字总个数，sum(temp[i])表示就目前为止小于等于temp[i]的个数。 &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; 小结 这是一种思路简单，代码实现简易的逆序对求法。唯一的不足就是常数可能会比较大。 复杂度为Θ(3×nlog⁡n)\\Theta(3\\times n\\log n)Θ(3×nlogn)。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"快速读入的玄学","slug":"qread","date":"2018-11-08T22:48:46.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/qread/","link":"","permalink":"https://www.micdz.cn/article/qread/","excerpt":"在面对超大数据的读入时，我们不得不面对快速的读入方式。","text":"在面对超大数据的读入时，我们不得不面对快速的读入方式。 测试用数据 测试所使用的数据通过以下代码生成。 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)int main() &#123; freopen(&quot;testdata.in&quot;,&quot;w&quot;,stdout); int n=100000; printf(&quot;%d\\n&quot;,n); srand(time(0)); REP(i,1,n) printf(&quot;%d\\n&quot;,rand()); return 0;&#125; 第一行一个整数nnn，接下来nnn行一个随机数，行末无空格。 使用cin读入测试用数据 测试用代码如下： 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)int main() &#123; freopen(&quot;testdata.in&quot;,&quot;r&quot;,stdin); double start=clock(); int n; cin&gt;&gt;n; int a; REP(i,1,n) cin&gt;&gt;a; double end=clock(); printf(&quot;%.3llf\\n&quot;,end-start); return 0;&#125; 如图所示 使用cin为2011ms。 使用scanf读入测试用数据 测试用代码如下： 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)int main() &#123; freopen(&quot;testdata.in&quot;,&quot;r&quot;,stdin); double start=clock(); int n; scanf(&quot;%d&quot;,&amp;n); int a; REP(i,1,n) scanf(&quot;%d&quot;,&amp;a); double end=clock(); printf(&quot;%.3llf\\n&quot;,end-start); return 0;&#125; 如图所示 使用scanf为970ms。 使用快读读入测试用数据 测试用代码如下： 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)int read() &#123; int x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int main() &#123; freopen(&quot;testdata.in&quot;,&quot;r&quot;,stdin); double start=clock(); int n; n=read(); int a; REP(i,1,n) a=read(); double end=clock(); printf(&quot;%.3llf\\n&quot;,end-start); return 0;&#125; 如图所示 使用快读为364ms。 使用关闭同步cin测试用数据 测试用代码如下： 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)int main() &#123; ios::sync_with_stdio(0); cin.tie(0); freopen(&quot;testdata.in&quot;,&quot;r&quot;,stdin); double start=clock(); int n; cin&gt;&gt;n; int a; REP(i,1,n) cin&gt;&gt;a; double end=clock(); printf(&quot;%.3llf\\n&quot;,end-start); return 0;&#125; 如图所示 使用关闭同步cin为624ms。 但是此方法极其不稳定，不建议使用。 小结 当面对大数据读入的时候，一定要记得使用快读或scanf。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"黑科技","slug":"黑科技","permalink":"https://www.micdz.cn/tags/%E9%BB%91%E7%A7%91%E6%8A%80/"}]},{"title":"线段树进阶","slug":"segment-tree-pro","date":"2018-11-08T16:47:03.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/segment-tree-pro/","link":"","permalink":"https://www.micdz.cn/article/segment-tree-pro/","excerpt":"在上篇文章中，已经进行了详细的对线段树单点修改和区间查询的描述。 在这篇文章中将会更深入的了解线段树的区间修改。不过，在NOIp赛事中，几乎很少出现。 这是一篇原始文章，不保证内容的正确性","text":"在上篇文章中，已经进行了详细的对线段树单点修改和区间查询的描述。 在这篇文章中将会更深入的了解线段树的区间修改。不过，在NOIp赛事中，几乎很少出现。 这是一篇原始文章，不保证内容的正确性 核心思路 在上篇文章中，已经证明了线段树的区间修改的时间复杂度是Θ(log⁡n)\\Theta(\\log n)Θ(logn)的，可以以此为思路研究区间修改的方法。 试想，如果我们在一次区间修改的操作中一次性将其子树的所有节点全部更新，而后面的查询操作根本不会用到这些节点，那么这些修改就完全浪费了。 我们在修改操作的时候对ppp加入一个标记，标识“该节点曾经修改，但其子节点尚未被跟新”，每一次查询操作的时候再将该标记向下传递。 我们称这种标记为“延迟标记”或“懒惰标记”。这就运用到了线段树优秀的性质。 接下来，我们以POJ3468为例，了解区间修改的线段树。 具体实现 建树、查询、修改的框架保持不变，用spread函数实现向下传递。 建树 用与上一篇一样，但是我们可以用几个宏定义的方法减少代码量。 12345678struct SegmentTree &#123; int l,r; ll sum,add; #define l(x) tree[x].l #define r(x) tree[x].r #define sum(x) tree[x].sum #define add(x) tree[x].add&#125; tree[MAXN&lt;&lt;2]; 利用上述的宏定义可以很方便地访问线段树。 建树过程 1234567891011void build(int p,int l,int r) &#123; l(p)=l,r(p)=r; if(l==r) &#123; sum(p)=a[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(p*2,l,mid); build(p*2+1,mid+1,r); sum(p)=sum(p*2)+sum(p*2+1);&#125; 传递标记 根据题目的维护内容改写。 123456789void speard(int p) &#123; if(add(p)) &#123; sum(p*2)+=add(p)*(r(p*2)-l(p*2)+1);//更新左字节点和 sum(p*2+1)+=add(p)*(r(p*2+1)-l(p*2+1));//更新右子节点和 add(p*2)+=add(p);//更新标记 add(p*2+1)+=add(p); add(p)=0;//切记不能忘记 &#125;&#125; 区间修改 思路算是比较简单，但是有许多细节容易忘记导致莫名RE或TLE。 123456789101112void change(int p,int l,int r,int d) &#123; if(l&lt;=l(p)&amp;&amp;r&gt;=r(p)) &#123;//完全覆盖 sum(p)+=d*(r(p)-l(p)+1);//这里是区间长度 add(p)+=d;//只更新当前节点信息 return ; &#125; spread(p);//向下传递 int mid=(l(p)+r(p))&gt;&gt;1; if(l&lt;=mid) change(p*2,l,r,d);//左区间覆盖 if(r&gt;mid) change(p*2+1,l,r,d);//右区间覆盖 sum(p)=sum(p*2)+sum(p*2+1);&#125; 区间查询 与上一篇所描述的方法几乎相同，只不过每一次查询都需要花一点点时间向下传递标志。 12345678ll ask(int p,int l,int r) &#123; if(l&lt;=l(p)&amp;&amp;r&gt;=r(p)) return sum(p); spread(p); ll val=0; if(l&lt;=mid) val+=ask(p*2,l,r); if(r&gt;mid) val+=ask(p*2+1,l,r); return val;&#125; 小结 在NOIp赛事中，使用线段树、数状数组、平衡树等高级的数据结构一般是在T3或毒瘤的T2，因此掌握好这些数据结构有助于我们在考场上快速想到正解。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"一些可以在考场上用到的vim快捷键","slug":"vim","date":"2018-11-06T15:16:30.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/vim/","link":"","permalink":"https://www.micdz.cn/article/vim/","excerpt":"即将参加NOIp2018考试，在此做一个备忘录。","text":"即将参加NOIp2018考试，在此做一个备忘录。 Ps: 在湖南赛区的NOIp得到noilinux中预置了廖老师的.vimrc文件。 注意，在廖老师配置的.vimrc中缺少了set mouse=a。 在终端中： 设置终端透明：键入metacity -c，在终端上方配置文件首选项即可在透明的vim下查看题面。 键入python2/3可以使用python。 在vim中： 复制粘贴：在选择模式下，键入y复制，p粘贴。 撤销与撤回撤销： 在普通模式下，键入u撤销，Ctrl+r撤回撤销。 删除当前行：在普通模式下，键入d+d删除。 强制退出vim：在命令模式下，键入:q!。 保存并退出：在命令模式下，键入:wq。 预祝大家取得完美成绩，RP++！ 2019.10.19更新 在vim下向普通的文本编辑器一样使用Ctrl复制粘贴的方法","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"【FLYIOI63】逃离 题解","slug":"FLYIOI63-solution","date":"2018-11-03T20:03:23.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/FLYIOI63-solution/","link":"","permalink":"https://www.micdz.cn/article/FLYIOI63-solution/","excerpt":"题目链接here 这是一道非常有思维难度和代码强度的宽搜好题。","text":"题目链接here 这是一道非常有思维难度和代码强度的宽搜好题。 题目大意 在一个地图中有两个人物和一些障碍物。 小z具有技能急速:每次移动可以走两步(允许这两步的方向不同,也允许不走第二步); 小m具有技能跳跃:若移动的方向为障碍且障碍后为空地,可借助障碍直接跳跃至空地。 计算两人相遇最少要花费多少秒。 如上图所示，黄色表示可以到达区域，黑色表示障碍物。 核心思路 通过数据范围可以发现此题的n≤1000n\\leq 1000n≤1000，就可以进行广搜，并且留下了可观的常数范围。 广搜小z 分解小z技能 小z的技能相当于在一秒内运用两次常规操作。因此我们只需要对小z做两次push即可。 小z的搜索代码 12345678910111213141516171819202122232425262728293031void bfs1(int xs,int ys) &#123; int tx[5]=&#123;0,1,0,-1,0&#125;; int ty[5]=&#123;0,0,1,0,-1&#125;; queue&lt;edge2&gt; q; q.push((edge2)&#123;0,xs,ys&#125;); have[xs][ys]=1; z[xs][ys]=0; while(!q.empty()) &#123; int x=q.front().xq,y=q.front().yq,s=q.front().s; q.pop(); if(a[x][y]) continue; for(int i=1; i&lt;=4; i++) &#123; int xx=x+tx[i],yy=y+ty[i]; if(xx&lt;1||xx&gt;n||yy&lt;1||yy&gt;n||a[xx][yy]) continue; if(!have[xx][yy]) &#123; have[xx][yy]=1; z[xx][yy]=s+1;//答案存在z数组中 q.push((edge2)&#123;s+1,xx,yy&#125;);//跳第一次到达的点 &#125; for(int j=1; j&lt;=4; j++) &#123; int xr=xx+tx[j],yr=yy+ty[j]; if(xr&lt;1||xr&gt;n||yr&lt;1||yr&gt;n||a[xr][yr]||have[xr][yr]) continue;//如果中间的这个点是障碍物则无法运用技能 have[xr][yr]=1; z[xr][yr]=s+1;//答案存在z数组中 q.push((edge2)&#123;s+1,xr,yr&#125;);//运用技能调达的点 &#125; &#125; &#125;&#125; 广搜小m 分解小m技能 小m的技能相当于如果常规操作跳到一个障碍物上，那么可以在跳跃方向上继续向前跳一格，但是要判断前面的这一格是否为障碍物。 小z的搜索代码 123456789101112131415161718192021222324252627282930313233void bfs1(int xs,int ys) &#123; int tx[5]=&#123;0,1,0,-1,0&#125;; int ty[5]=&#123;0,0,1,0,-1&#125;; queue&lt;edge&gt; q; q.push((edge)&#123;xs,ys&#125;); while(!q.empty()) &#123; int x=q.front().xq,y=q.front().yq; q.pop(); for(int i=1; i&lt;=4; i++) &#123; int xx=x+tx[i],yy=y+ty[i]; if(have[xx][yy]||xx&lt;1||xx&gt;n||yy&lt;1||yy&gt;n) continue; if(a[xx][yy]) &#123; if(i==1) xx++; if(i==2) yy++; if(i==3) xx--; if(i==4) yy--; &#125;//如果xx,yy是障碍物则跳过障碍物，针对不同的来路要跳到指定的地方 if(have[xx][yy]||xx&lt;1||xx&gt;n||yy&lt;1||yy&gt;n) continue; if(!a[xx][yy]) &#123; m[xx][yy]=min(m[xx][yy],m[x][y]+1);//答案存储在m数组中 q.push((edge)&#123;xx,yy&#125;); have[xx][yy]=1; &#125; &#125; &#125;&#125; 统计答案 Θ(nm)\\Theta(nm)Θ(nm)扫整个图一遍，找到max⁡(zi,j,mi,j)\\max(z_{i,j},m_{i,j})max(zi,j​,mi,j​)最小的点。 1234for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) &#123; ans=min(ans,max(m[i][j],z[i][j])); &#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 1000+10#define INF 0x3f3f3f3fint read() &#123; int x=0,f=1; char ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int n,xa,xb,ya,yb;int a[MAXN][MAXN];int z[MAXN][MAXN],m[MAXN][MAXN];void debug1() &#123; cout&lt;&lt;endl; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; printf(&quot;%3d&quot;,m[i][j]==INF?0:m[i][j]); &#125; cout&lt;&lt;endl; &#125;&#125;void debug2() &#123; cout&lt;&lt;endl; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; printf(&quot;%3d&quot;,(z[i][j]==INF?0:z[i][j])); &#125; cout&lt;&lt;endl; &#125;&#125;struct edge&#123; int xq,yq;&#125;;int have[MAXN][MAXN];void bfs1(int xs,int ys) &#123; int tx[5]=&#123;0,1,0,-1,0&#125;; int ty[5]=&#123;0,0,1,0,-1&#125;; queue&lt;edge&gt; q; q.push((edge)&#123;xs,ys&#125;); while(!q.empty()) &#123; int x=q.front().xq,y=q.front().yq; q.pop(); for(int i=1; i&lt;=4; i++) &#123; int xx=x+tx[i],yy=y+ty[i]; if(have[xx][yy]||xx&lt;1||xx&gt;n||yy&lt;1||yy&gt;n) continue; if(a[xx][yy]) &#123; if(i==1) xx++; if(i==2) yy++; if(i==3) xx--; if(i==4) yy--; &#125; if(have[xx][yy]||xx&lt;1||xx&gt;n||yy&lt;1||yy&gt;n) continue; if(!a[xx][yy]) &#123; m[xx][yy]=min(m[xx][yy],m[x][y]+1); q.push((edge)&#123;xx,yy&#125;); have[xx][yy]=1; &#125; &#125; &#125;&#125;struct edge2&#123; int s,xq,yq;&#125;;void bfs2(int xs,int ys) &#123; int tx[5]=&#123;0,1,0,-1,0&#125;; int ty[5]=&#123;0,0,1,0,-1&#125;; queue&lt;edge2&gt; q; q.push((edge2)&#123;0,xs,ys&#125;); have[xs][ys]=1; z[xs][ys]=0; while(!q.empty()) &#123; int x=q.front().xq,y=q.front().yq,s=q.front().s; q.pop(); if(a[x][y]) continue; for(int i=1; i&lt;=4; i++) &#123; int xx=x+tx[i],yy=y+ty[i]; if(xx&lt;1||xx&gt;n||yy&lt;1||yy&gt;n||a[xx][yy]) continue; if(!have[xx][yy]) &#123; have[xx][yy]=1; z[xx][yy]=s+1; q.push((edge2)&#123;s+1,xx,yy&#125;); &#125; for(int j=1; j&lt;=4; j++) &#123; int xr=xx+tx[j],yr=yy+ty[j]; if(xr&lt;1||xr&gt;n||yr&lt;1||yr&gt;n||a[xr][yr]||have[xr][yr]) continue; have[xr][yr]=1; z[xr][yr]=s+1; q.push((edge2)&#123;s+1,xr,yr&#125;); &#125; &#125; &#125;&#125;int main() &#123; n=read(),xa=read(),ya=read(),xb=read(),yb=read(); for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) a[i][j]=getchar()-&#x27;0&#x27;; getchar(); &#125; for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) m[i][j]=INF,z[i][j]=INF; m[xb][yb]=0; bfs1(xb,yb); for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) have[i][j]=0; z[xa][ya]=0; bfs2(xa,ya); //debug1(); //debug2(); int ans=INF; for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) &#123; ans=min(ans,max(m[i][j],z[i][j])); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 小结 此题码量较大，细节较多。调试较困难，一遍AC较难。 但是是一道练习广搜的好题。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"bfs","slug":"bfs","permalink":"https://www.micdz.cn/tags/bfs/"},{"name":"搜索","slug":"搜索","permalink":"https://www.micdz.cn/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"浅析tarjan算法","slug":"basic-tarjan","date":"2018-11-02T16:18:30.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/basic-tarjan/","link":"","permalink":"https://www.micdz.cn/article/basic-tarjan/","excerpt":"几乎网上所有有关tarjan算法的介绍都会有下面这一段话： Tarjan老爷子一生发明了许多算法下到 NOIP 上到 CTSC 难度的都有。 (Tarjan 算法，并查集，Splay 树，Tarjan 离线求 lca) 我们这里要介绍的是图论中的 Tarjan 算法，用来处理各种连通性相关的问题。","text":"几乎网上所有有关tarjan算法的介绍都会有下面这一段话： Tarjan老爷子一生发明了许多算法下到 NOIP 上到 CTSC 难度的都有。 (Tarjan 算法，并查集，Splay 树，Tarjan 离线求 lca) 我们这里要介绍的是图论中的 Tarjan 算法，用来处理各种连通性相关的问题。 有向图连通性 一些定义 给定有向图 G=(V,E)G=(V,E)G=(V,E) ，若存在 r∈Vr\\in Vr∈V ，满足从 rrr 出发能到达 VVV 中的所有点，则称 GGG 为一个“流图”，其中 rrr 称为流图的源点。 在流图的深度优先遍历中，按照每个节点第一次被访问的顺序，以此给予NNN个节点 1−n1-n1−n 的整数标记，该标记就称为 dfn[x]dfn[x]dfn[x] ，中文名为“时间戳”。 给定一张有向图，若对于图中任意两个节点 xxx , yyy ，既存在 xxx 到 yyy 的路径，又存在从 yyy 到 xxx 的路径，则称该有向图强连通。 强连通分量在有向图G中，如果两个顶点 xxx , yyy 间 (x&gt;y)(x&gt;y)(x&gt;y) 有一条从 xxx 到 yyy 的有向路径，同时还有一条从 xxx 到 yyy 的有向路径。 如下图： 此图是一个非常经典的例图 在图中， {1,2,3}\\{1,2,3\\}{1,2,3} 在同一个强连通分量， {4}\\{4\\}{4} 和 {5}\\{5\\}{5} 单独两个强连通分量。 在强连通图中各种类型的边，定义边 (x,y)(x,y)(x,y) 满足以下条件。 树枝边，指搜索树中的边，即 xxx 是 yyy 的父节点 前向边， xxx 是 yyy 的祖先节点 后向边， yyy 是 xxx 的祖先节点 横叉边，除了以上条件的所有边，这种边一定满足 dfn[y]&lt;dfn[x]dfn[y]&lt;dfn[x]dfn[y]&lt;dfn[x] Tarjan求强连通分量 核心思路 初始化 在刚刚遍历到某一个节点时初始化 lowlowlow 和 dfndfndfn 。 而为什么此时的 lowlowlow 可以等于 dfndfndfn ，请自行证明。 对于上面的那一张图，转化成一个流图即为 利用栈存储 每次到达一个节点时，就将该节点压入栈中，并且记录下该节点已入栈。 当某一节点的出边的 low==dfnlow==dfnlow==dfn 时，就将栈顶推出直至某一节点与栈顶相同为止，此时推出的所有节点均为同一强连通分量的节点，并且没有其他节点与此强连通。 完整代码 1234567891011121314151617181920212223void tarjan(int x) &#123; dfn[x]=low[x]=++num; _stack[++top]=x; ins[x]=1; for(int i=head[x]; i; i=_next[i]) &#123; int v=to[i]; if(!dfn[v]) &#123; tarjan(v); low[x]=min(low[x],low[v]); &#125; else if(ins[v]) low[x]=min(low[x],low[v]); &#125; if(dfn[x]==low[x]) &#123; cntt++; int y; do&#123; y=_stack[top--]; ins[y]=0; c[y]=cntt; scc[cntt].push_back(y); &#125;while(x!=y); &#125;&#125; 在上述的代码中scc存储的的是新的有向无环图。c数组存储的是强连通分量。 我们可以通过下面的这段代码建出新的有向无环图。 12345678910111213void addedge_c(int u,int v) &#123; cnt++; to_c[cnt]=v; _next_c[cnt]=head_c[u]; head_c[u]=cnt;&#125;//在main()中for(int x=1; x&lt;=n; x++) for(int i=head[x]; i; i=_next[i]) &#123; int y=to[i]; if(c[x]==c[y]) continue; add_c(c[x],c[y]); &#125; 对应例题 Network of SchoolsPOJ1236 Popular CowsPOJ2186 消息扩散LG2002 无向图连通性 一些定义 给定无向连通图 G=(V,E)G=(V,E)G=(V,E)： 若对于 x∈Vx\\in Vx∈V ，从图中删除 xxx 与其相邻的所有的边，使 GGG 分裂为两个或两个以上的子图，则称 xxx 为 GGG 的割点。 若对于 e∈Ee\\in Ee∈E ，从图中删除 eee ，使 GGG 分裂为两个或两个以上的子图，则称 eee 为 GGG 的割边或桥。 与有向图相似的 dfndfndfn 与 lowlowlow 。 Tarjan求割点与桥 核心思路 割边判定法则 如果边 (x,y)(x,y)(x,y) 是一个桥，当且仅当满足： dfnx&lt;lowy\\begin{aligned} dfn_x&lt;low_y \\end{aligned} dfnx​&lt;lowy​​ 有了上述的判定法则，就可以很轻松地在有向图的基础上该写出割边的代码。 特别的，我们可以引用一个bridge来存储割边的左右节点。 完整代码 12345678910111213void tarjan(int x,int in_edge) &#123; dfn[x]=low[x]=++num; for(int i=head[x]; i; i=_next[i]) &#123; int y=to[i]; if(!dfn[y]) &#123; tarjan(y,i); low[x]=min(low[x],low[y]);//与有向图相同的操作 if(low[y]&gt;dfn[x]) bridge[i]=bridge[i^1]=1;//判定为割边 else if(i!=(in_bridge^1)) low[x]=min(low[x],dfn[y]); &#125; &#125;&#125; 对应例题 暂无 割点判定法则 当 xxx 不是搜索树的根节点，如果 xxx 是割点当且仅当搜索树上存在 xxx 的一个子节点 yyy 。满足： dfnx≤lowy\\begin{aligned} dfn_x\\leq low_y \\end{aligned} dfnx​≤lowy​​ 完整代码 12345678910111213141516void tarjan(int x) &#123; dfn[x]=low[x]=++num; int flag=0; for(int i=head[x]; i; i=_next[i]) &#123; int y=to[i]; if(!dfn[y]) &#123; tarjan(y); low[x]=min(low[x],low[y]); if(low[y]&gt;=dfn[x]) &#123; flag++; if(x!=root||flag&gt;1) cut[x]=1; &#125; &#125; else low[x]=min(low[x],dfn[y]); &#125;&#125; 对应例题 【模板】割点（割顶）LG3388","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://www.micdz.cn/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}]},{"title":"【CF1066F】Yet another 2D Walking 题解","slug":"CF1066F-solution","date":"2018-11-02T11:43:32.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/CF1066F-solution/","link":"","permalink":"https://www.micdz.cn/article/CF1066F-solution/","excerpt":"此题可以用动态规划求解。","text":"此题可以用动态规划求解。 题目描述 题目链接here 小M在平面直角坐标系上的(0,0)(0,0)(0,0)点。他每次可以向上下左右走一格。 如果两个点满足max⁡(Xi,Yi)≤max⁡(Xj,Yj)\\max(X_i,Y_i)\\leq \\max(X_j,Y_j)max(Xi​,Yi​)≤max(Xj​,Yj​)，那么从iii到jjj就有一条有向路径。 定义两点的距离为曼哈顿距离。 最小化路径长度。 核心思路 我们将所有的点按照max⁡(x,y)\\max(x,y)max(x,y)分层，就如上图所示。可以证明只有到达某一层并且将该层完全走完再走下一层是最优的。 定义dpi,0dp_{i,0}dpi,0​表示到达第iii条边的左端点的最小路径，dpi,1dp_{i,1}dpi,1​表示到达第iii条边的右端点的最小路径。 转移方程显然。 dpi,1=min⁡(dpi−1,1+dist(righti−1,lefti),dpi−1,0+dist(lefti−1,lefti))+disi−1;dpi,0=min⁡(dpi−1,1+dist(righti−1,righti),dpi−1,0+dist(lefti−1,righti))+disi−1;\\begin{aligned} dp_{i,1}&amp;=\\min(dp_{i-1,1}+dist(right_{i-1},left_i),dp_{i-1,0}+dist(left_{i-1},left_i))+dis_{i-1};\\\\ dp_{i,0}&amp;=\\min(dp_{i-1,1}+dist(right_{i-1},right_i),dp_{i-1,0}+dist(left_{i-1},right_i))+dis_{i-1};\\\\ \\end{aligned} dpi,1​dpi,0​​=min(dpi−1,1​+dist(righti−1​,lefti​),dpi−1,0​+dist(lefti−1​,lefti​))+disi−1​;=min(dpi−1,1​+dist(righti−1​,righti​),dpi−1,0​+dist(lefti−1​,righti​))+disi−1​;​ 在方程中disdisdis表示某一层走完的长度。 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define REP(i,e,s) for(register int i=e; i&lt;=s; i++)#define DREP(i,e,s) for(register int i=e; i&gt;=s; i--)#define MAXN 200000+10ll read() &#123; ll x=0,f=1,ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;struct edge&#123; ll x,y,id;&#125;a[MAXN];bool cmp(edge a,edge b) &#123; ll as=max(a.x,a.y),bs=max(b.x,b.y); if(as==bs) &#123;if(a.x==b.x) return a.y&gt;=b.y;else return a.x&lt;b.x;&#125; return as&lt;bs;&#125;ll dist(ll u,ll v) &#123; return abs(a[u].x-a[v].x)+abs(a[u].y-a[v].y);&#125;ll _right[MAXN],_left[MAXN],dis[MAXN];ll dp[MAXN][2];int main() &#123; ll n=read(); REP(i,1,n) &#123; a[i].x=read(); a[i].y=read(); a[i].id=max(a[i].x,a[i].y); &#125; sort(a+1,a+1+n,cmp); ll now=-1,cnt=0; ll ans=0; REP(i,1,n) &#123; if(a[i].id!=a[i-1].id) &#123; _right[cnt]=i-1; dis[cnt]=dist(_right[cnt],_left[cnt]); _left[++cnt]=i; &#125; &#125; _right[cnt]=n; dis[cnt]=dist(_right[cnt],_left[cnt]); REP(i,1,cnt) &#123; dp[i][1]=min(dp[i-1][1]+dist(_right[i-1],_left[i]),dp[i-1][0]+dist(_left[i-1],_left[i]))+dis[i-1]; dp[i][0]=min(dp[i-1][1]+dist(_right[i-1],_right[i]),dp[i-1][0]+dist(_left[i-1],_right[i]))+dis[i-1]; &#125; cout&lt;&lt;min(dp[cnt][1],dp[cnt][0])+dis[cnt]&lt;&lt;endl; return 0;&#125;//考场代码略丑","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.micdz.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"期望与微积分","slug":"expectation-calculus","date":"2018-11-01T17:30:41.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/expectation-calculus/","link":"","permalink":"https://www.micdz.cn/article/expectation-calculus/","excerpt":"以NOIp2018初赛第7题为例： 12345 7. 在一条长度为1 的线段上随机取两个点，则以这两个点为端点的线段的期望长度是（ ）。A. 1 &#x2F; 2B. 1 &#x2F; 3C. 2 &#x2F; 3D. 3 &#x2F; 5","text":"以NOIp2018初赛第7题为例： 12345 7. 在一条长度为1 的线段上随机取两个点，则以这两个点为端点的线段的期望长度是（ ）。A. 1 &#x2F; 2B. 1 &#x2F; 3C. 2 &#x2F; 3D. 3 &#x2F; 5 首先您需要理解期望是什么。 假设您买彩票，不中奖概率为505050%，得到1元的概率为303030%，得到505050%元的概率为151515%，得到100010001000元的概率为555%，那么记 买彩票获得的奖金 这个事件为AAA，那么获得的奖金期望值记做E(A)E(A)E(A) 那么E(A)=0∗0.5+1∗0.3+50∗0.15+1000∗0.05=57.8E(A)=0*0.5+1*0.3+50*0.15+1000*0.05=57.8E(A)=0∗0.5+1∗0.3+50∗0.15+1000∗0.05=57.8 如您见，就是每一种可能乘上对应的概率之和 我们可以来看这道题了。 这道题要用的一点微积分的思想。把这个线段平均分成nnn段，然后枚举左右端点，算出所有可能的值，再求平均值即可！ 可能广大初中生并不知道怎么算，我来写一下过程吧 下面先求总长度 ∑i=0n∑j=0n∣i−j∣n\\sum_{i=0}^n \\sum_{j=0}^n \\dfrac{\\lvert i-j \\rvert}{n}∑i=0n​∑j=0n​n∣i−j∣​ 考虑把第二层求和拆开 =∑i=0n(∣i−0∣n+∣i−1∣n+...+∣i−n∣n)=\\sum_{i=0}^n (\\dfrac{\\lvert i-0 \\rvert}{n}+\\dfrac{\\lvert i-1 \\rvert}{n}+...+\\dfrac{\\lvert i-n \\rvert}{n})=∑i=0n​(n∣i−0∣​+n∣i−1∣​+...+n∣i−n∣​) 分母相同，分子写到一起去 =∑i=0n(∣i−0∣+∣i−1∣+∣i−2∣+...+∣i−n∣n)=\\sum_{i=0}^n (\\dfrac{\\lvert i-0 \\rvert+\\lvert i-1\\rvert+\\lvert i-2 \\rvert+...+|i-n|}{n})=∑i=0n​(n∣i−0∣+∣i−1∣+∣i−2∣+...+∣i−n∣​) 陷入瓶颈 如果右边这一坨东西是个等差数列就好了，但事实上不是，but……我们可以找一点规律 我们以n=4n=4n=4为例子吧 |∣i−j∣4\\frac{|i-j|}{4}4∣i−j∣​ | 0 | 1 | 2 | 3 |4| | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | | 0 | 000 | 14\\dfrac{1}{4}41​ | 24\\dfrac{2}{4}42​ | 34\\dfrac{3}{4}43​ | 44\\dfrac{4}{4}44​ | | 1 | 14\\dfrac{1}{4}41​ | 000 | 14\\dfrac{1}{4}41​ |24\\dfrac{2}{4}42​ | 34\\dfrac{3}{4}43​ | | 2| 24\\dfrac{2}{4}42​ | 14\\dfrac{1}{4}41​ | 000 | 14\\dfrac{1}{4}41​ | 24\\dfrac{2}{4}42​ | | 3| 34\\dfrac{3}{4}43​ | 24\\dfrac{2}{4}42​ | 14\\dfrac{1}{4}41​ | 000 | 14\\dfrac{1}{4}41​ | | 4 | 44\\dfrac{4}{4}44​ | 34\\dfrac{3}{4}43​ | 24\\dfrac{2}{4}42​ | 14\\dfrac{1}{4}41​ | 000 | 规律十分明显，每一行都** 以000为分界线拆成两个等差数列 **！于是我们可以愉快地往下面写了！ =∑i=0n((0+i)∗(i+1)+(0+n−i)∗(n−i+1)2n)=\\sum_{i=0}^n (\\dfrac{(0+i)*(i+1)+(0+n-i)*(n-i+1)}{2n})=∑i=0n​(2n(0+i)∗(i+1)+(0+n−i)∗(n−i+1)​) 然后愉快的化简！ =∑i=0n(i2+i+n2−ni+1−ni+i2−i2n)=\\sum_{i=0}^n (\\dfrac{i^2+i+n^2-ni+1-ni+i^2-i}{2n})=∑i=0n​(2ni2+i+n2−ni+1−ni+i2−i​) 合并同类项 =∑i=0n(2i2−2ni+n2+12n)=\\sum_{i=0}^n (\\dfrac{2i^2-2ni+n^2+1}{2n})=∑i=0n​(2n2i2−2ni+n2+1​) 分离常数 =∑i=0n(2i22n−2ni2n+n2+n2n)=\\sum_{i=0}^n (\\dfrac{2i^2}{2n}-\\dfrac{2ni}{2n}+\\dfrac{n^2+n}{2n})=∑i=0n​(2n2i2​−2n2ni​+2nn2+n​) =∑i=0n(i2n−i+n+12)=\\sum_{i=0}^n (\\dfrac{i^2}{n}-i+\\dfrac{n+1}{2})=∑i=0n​(ni2​−i+2n+1​) 然后可以愉快的拆开 ∑\\sum∑ 了！ =02+12+22+32...+n2n−(0+1+2...+n)+(n+1)(n+1)2=\\dfrac{0^2+1^2+2^2+3^2...+n^2}{n}-(0+1+2...+n)+\\dfrac{(n+1)(n+1)}{2}=n02+12+22+32...+n2​−(0+1+2...+n)+2(n+1)(n+1)​ =02+12+22+32...+n2n−(0+n)∗(n+1)2+(n+1)22=\\dfrac{0^2+1^2+2^2+3^2...+n^2}{n}-\\dfrac{(0+n)*(n+1)}{2}+\\dfrac{(n+1)^2}{2}=n02+12+22+32...+n2​−2(0+n)∗(n+1)​+2(n+1)2​ 陷入瓶颈 我们被卡住关键在于Sn=02+12+22+32...+n2S_n=0^2+1^2+2^2+3^2...+n^2Sn​=02+12+22+32...+n2的计算（高中不必看这一段），那么我们不如来推一推公式吧？ 怎么推公式？ 玄学技巧-差分 把n∈[0,5]n\\in[0,5]n∈[0,5]的SnS_nSn​值列成一排 0 1 5 14 30 550~~~~~~~~1~~~~~~~~5~~~~~~~~14~~~~~~~~30~~~~~~~~550 1 5 14 30 55 ~~~~~~~~ 然后差分 1 4 9 16 25~~~~1~~~~~~~~4~~~~~~~~9~~~~~~~~16~~~~~~~~25 1 4 9 16 25 ~~~~~~~~~~~~~~~~ 继续 3 5 7 9~~~~~~~~3~~~~~~~~5~~~~~~~~7~~~~~~~~9 3 5 7 9 ~~~~~~~~~~~~~~~~~~~~~~~~~~ 继续 2 2 2~~~~~~~~~~~~2~~~~~~~~2~~~~~~~~2 2 2 2 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 所有的数字竟然相等了！ 这时候我们一共做了333次差分操作，那么我们可以得知SnS_nSn​公式是一个333次整式！ 玄学吧 此时设S=ax3+bx2+cx+dS=ax^3+bx^2+cx+dS=ax3+bx2+cx+d {a+b+c+d=18a+4b+2c+d=527a+9b+3c+d=1464a+16b+4c+d=30\\begin{cases} a+b+c+d=1 \\\\ 8a+4b+2c+d=5 \\\\ 27a+9b+3c+d=14 \\\\ 64a+16b+4c+d=30\\end{cases}⎩⎪⎪⎪⎨⎪⎪⎪⎧​a+b+c+d=18a+4b+2c+d=527a+9b+3c+d=1464a+16b+4c+d=30​ 然后解方程 {7a+3b+c=419a+5b+c=937a+7b+c=16\\begin{cases} 7a+3b+c=4 \\\\ 19a+5b+c=9 \\\\ 37a+7b+c=16 \\end{cases}⎩⎪⎨⎪⎧​7a+3b+c=419a+5b+c=937a+7b+c=16​ {12a+2b=518a+2b=7\\begin{cases} 12a+2b=5 \\\\ 18a+2b=7 \\end{cases}{12a+2b=518a+2b=7​ 6a=2 ∴a=136a=2~~~~~~~\\therefore a=\\dfrac{1}{3}6a=2 ∴a=31​ ∴b=12,c=16,d=0\\therefore b=\\dfrac{1}{2},c=\\dfrac{1}{6},d=0∴b=21​,c=61​,d=0 ∴Sn=13n3+12n2+16n\\therefore S_n=\\dfrac{1}{3}n^3+\\dfrac{1}{2}n^2+\\dfrac{1}{6}n∴Sn​=31​n3+21​n2+61​n 化简一下 =16n(2n2+3n+1)=\\dfrac{1}{6}n(2n^2+3n+1)=61​n(2n2+3n+1) 十字相乘分解 =16n(n+1)(2n+1)=\\dfrac{1}{6}n(n+1)(2n+1)=61​n(n+1)(2n+1) 然后就可以愉快的往下面写了 02+12+22+32...+n2n−(0+n)∗(n+1)2+(n+1)22\\dfrac{0^2+1^2+2^2+3^2...+n^2}{n}-\\dfrac{(0+n)*(n+1)}{2}+\\dfrac{(n+1)^2}{2}n02+12+22+32...+n2​−2(0+n)∗(n+1)​+2(n+1)2​ =16n(n+1)(2n+1)n−(0+n)∗(n+1)2+(n+1)22=\\dfrac{\\dfrac{1}{6}n(n+1)(2n+1)}{n}-\\dfrac{(0+n)*(n+1)}{2}+\\dfrac{(n+1)^2}{2}=n61​n(n+1)(2n+1)​−2(0+n)∗(n+1)​+2(n+1)2​ =16(n+1)(2n+1)−n2+n2+n2+2n+12=\\dfrac{1}{6}(n+1)(2n+1)-\\dfrac{n^2+n}{2}+\\dfrac{n^2+2n+1}{2}=61​(n+1)(2n+1)−2n2+n​+2n2+2n+1​ =(n+1)(2n+1)6+n+12=\\dfrac{(n+1)(2n+1)}{6}+\\dfrac{n+1}{2}=6(n+1)(2n+1)​+2n+1​ =2n2+3n+16+3n+36=\\dfrac{2n^2+3n+1}{6}+\\dfrac{3n+3}{6}=62n2+3n+1​+63n+3​ =2n2+6n+46=\\dfrac{2n^2+6n+4}{6}=62n2+6n+4​ =n2+3n+23=\\dfrac{n^2+3n+2}{3}=3n2+3n+2​ =(n+1)(n+2)3=\\dfrac{(n+1)(n+2)}{3}=3(n+1)(n+2)​ 那么总长度算了出来，再除以情况数(n+1)2(n+1)^2(n+1)2 Ans=(n+1)(n+2)3(n+1)2Ans=\\dfrac{(n+1)(n+2)}{3(n+1)^2}Ans=3(n+1)2(n+1)(n+2)​ =n+23n+3​=\\dfrac{n+2}{3n+3}​=3n+3n+2​​ lim⁡Δx→∞Ans=13\\lim_{\\Delta x\\to \\infty}Ans=\\dfrac{1}{3}limΔx→∞​Ans=31​ 至此，我们做出了这道题，答案选BBB By Imakf https://www.luogu.org/blog/Imakf/noip-ti-gao-chu-sai-t7-xie-xi","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"期望","slug":"期望","permalink":"https://www.micdz.cn/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"微积分","slug":"微积分","permalink":"https://www.micdz.cn/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"}]},{"title":"中东及非洲南部水资源现状及解决措施","slug":"sf-ea-water-resources","date":"2018-10-21T11:55:14.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/sf-ea-water-resources/","link":"","permalink":"https://www.micdz.cn/article/sf-ea-water-resources/","excerpt":"中东和非洲所面临的水资源情况不容乐观。对于这两个区域的水资源讨论是十分有意义的。","text":"中东和非洲所面临的水资源情况不容乐观。对于这两个区域的水资源讨论是十分有意义的。","categories":[{"name":"Others","slug":"Others","permalink":"https://www.micdz.cn/categories/Others/"}],"tags":[{"name":"论文","slug":"论文","permalink":"https://www.micdz.cn/tags/%E8%AE%BA%E6%96%87/"}]},{"title":"线段树","slug":"segment-tree","date":"2018-10-11T23:28:35.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/segment-tree/","link":"","permalink":"https://www.micdz.cn/article/segment-tree/","excerpt":"线段树是一种基于分治思想的二叉树结构。用于在区间上进行信息统计。于树状数组相比，线段树更为通用。 这是一篇原始文章，不保证内容的正确性","text":"线段树是一种基于分治思想的二叉树结构。用于在区间上进行信息统计。于树状数组相比，线段树更为通用。 这是一篇原始文章，不保证内容的正确性 实现目标 区间修改 区间查询 可以基于所有具有可互逆运算法则的运算。 核心思路 线段树的建立 在基础数据结构一文中，我有提到线段树是如上的结构。更为准确地描述，应该是一个二叉树。上图也可以很好地表现这一点。 那么就可以使用存储二叉树的方式来存储线段树。 1234struct SegmentTree&#123; int l,r; int dat;&#125; t[MAXN&lt;&lt;2]; 也可以使用链式前向星或是邻接表。但是因为已经是二叉树的结构就没有必要了。 这里我们以查找最大值为例。其实任何有逆运算及结合律的操作都可以用线段树维护，这是因为线段树在合并时需要从左子树及右子树统计答案需要满足结合律，如果没有逆运算则无法更新答案。 每一个节点代表的区间是从根节点的整个长度出发依次分半直至不能再分为止。因此线段树的每一个节点都表示一个区间的最大值，特别的每一个叶子节点就表示一个数（其实一个数也可以是一个区间）。 1234567891011void build(int p,int l,int r) &#123; t[p].l=l,t[p].r=r; if(l==r) &#123; t[p].dat=a[l]; return ; &#125;//叶子节点的情况 int mid=(l+r)/2; build(p*2,l,mid);//左子树 build(p*2+1,mid+1,r);//右子树 t[p].dat=max(t[p*2].dat,t[p*2+1].dat);//更新答案&#125; 单点修改 与建树十分相似。但是我们只需要找到xxx的位置即可。 12345678910void change(int p,int x,int v) &#123; if(t[p].l==t[p].r) &#123; t[p].dat=v; return ; &#125;//找到叶节点并修改 int mid=(t[p].l+t[p].r)/2; if(x&lt;=mid) change(p*2,x,v); else change(p*2+1,x,v);//在左区间还是右区间 t[p].dat=max(t[p*2].dat,t[p*2+1].dat);//更新答案&#125; 调用入口为，将第xxx个节点更改为vvv。 1change(1,x,v); 区间查询 区间查询分为以下三种情况： 所查找的子区间将当前节点区间完全包含，直接得出答案 所查找的子区间与当前节点的左子节点有重叠 所查找的子区间与当前节点的右子节点有重叠 对应三种情况我们可以用三个if语句解决。 12345678int ask(int p,int l,int r) &#123; int mid=(t[p].l+t[p].r)/2; int val=-INF; if(l&lt;=t[p].l&amp;&amp;r&gt;=t[p].r) return t[p].dat; if(l&lt;=mid) val=max(val,ask(p*2,l,r)); if(r&gt;mid) val=max(val,ask(p*2+1,l,r)); //切记此处不能写为else if&#125; 调用入口为，返回值为答案。 1ask(1,l,r); 考虑查询操作的时间复杂度： 查询操作会将区间[l.r][l.r][l.r]在线段树上分为log⁡n\\log nlogn个节点。但是因为存在左子区间或右子区间有重叠的情况有可能会向下查找两次。但好在这种情况最多出现一次。 因此查询操作的复杂度为Θ(2log⁡n)=Θ(log⁡n)\\Theta(2\\log n)=\\Theta(\\log n)Θ(2logn)=Θ(logn)。 有关线段树的更多操作，请参考线段树进阶","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【HDU1520】Anniversary party s题解","slug":"HDU1520-solution","date":"2018-10-10T23:12:23.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/HDU1520-solution/","link":"","permalink":"https://www.micdz.cn/article/HDU1520-solution/","excerpt":"题目链接here，是目前公认的树形dp的入门模板题。 思路还是比较简单的。","text":"题目链接here，是目前公认的树形dp的入门模板题。 思路还是比较简单的。 题目大意 由若干个人在举行派对，给定你若干对从属关系，要求具有从属关系的两人不能同时参加派对，每个人都有一个权值让你求出权值的最大是多少。 核心思路 状态设计 因为对于每一个节点都会有两种状态分别为选择和不选择，记f[i][1]f[i][1]f[i][1]表示以iii为根结点的子树当选择了iii的最大权值和，而f[i][0]f[i][0]f[i][0]表示以iii为根结点的子树当没有选择iii的最大权值和。 对于任意叶子结点kkk，f[k][1]f[k][1]f[k][1]即为该节点的权值，而f[k][0]f[k][0]f[k][0]即为0。 状态转移方程 得到了上述的关系，我们可以发现，假设在一对从属关系中，“属点”是uuu，“从点”是vvv（即uuu是vvv的领导），将会有一条边从uuu指向vvv，并且当uuu被选择时，vvv就不能被选择，而uuu不被选择时vvv可以不被选择，也可以不选择。 因此方程如下： f[u][1]=∑max⁡(f[v][0],f[v][1])f[u][0]=∑f[v][0]\\begin{aligned} f[u][1]&amp;=\\sum\\max(f[v][0],f[v][1])\\\\ f[u][0]&amp;=\\sum f[v][0]\\\\ \\end{aligned} f[u][1]f[u][0]​=∑max(f[v][0],f[v][1])=∑f[v][0]​ 所以只需要dfs从根节点向叶子结点遍历，在回溯时修改即可。 dfs遍历 12345678910void dfs(int u) &#123; int fa=0,tu=a[u]; for(int i=head[u]; i; i=_next[i]) &#123; int v=to[i]; dfs(v); //切记是在回溯的时候修改 &#125; dp[u][0]=fa,dp[u][1]=tu;&#125; 我这里使用的是链式前向星存图，当然也可以使用邻接表。邻接矩阵有可能会超时。 dfs遍历的过程应该很好理解，在回溯的时候才可以更新答案。入口是dfs(root)。 寻找根节点 根据上面所说的需要寻找根节点，根据根节点的定义，入度为0的节点即为根节点。 在存图的时候加入一个数组记录下每个节点的入度即可。 值得注意的是有些题目会有多棵树，而有些题会明确指出只有一棵树，因此使用下面的代码最为保险。 123456for(int i=1; i&lt;=n; i++) &#123; if(!root[i]) &#123; dfs(i); //统计答案 &#125;&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 6000+15#define MAXM 6000+15int read() &#123; int x=0,f=1; char ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int head[MAXN],to[MAXM],a[MAXM],_next[MAXN],root[MAXN],cnt;void addedge(int u,int v) &#123; cnt++; to[cnt]=v; _next[cnt]=head[u]; head[u]=cnt;&#125;int dp[MAXN][2];void init() &#123; memset(root,0,sizeof(root)); memset(head,0,sizeof(head)); memset(dp,0,sizeof(dp)); cnt=0;&#125;void dfs(int u) &#123; int fa=0,tu=a[u]; for(int i=head[u]; i; i=_next[i]) &#123; int v=to[i]; dfs(v); fa=max(fa,fa+max(dp[v][0],dp[v][1])); tu=max(tu,tu+dp[v][0]); &#125; dp[u][0]=fa,dp[u][1]=tu;&#125;int main() &#123; int n; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; init(); for(int i=1; i&lt;=n; i++) a[i]=read(); int u,v; while(scanf(&quot;%d%d&quot;,&amp;u,&amp;v)==2&amp;&amp;u+v) &#123; addedge(v,u); root[u]=1; &#125; int ans=0; for(int i=1; i&lt;=n; i++) &#123; if(!root[i]) &#123; dfs(i); ans+=max(dp[i][0],dp[i][1]); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.micdz.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形dp","slug":"树形dp","permalink":"https://www.micdz.cn/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"dfs","slug":"dfs","permalink":"https://www.micdz.cn/tags/dfs/"}]},{"title":"中秋节欢乐赛题解","slug":"zqj-solutions","date":"2018-09-23T17:09:16.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/zqj-solutions/","link":"","permalink":"https://www.micdz.cn/article/zqj-solutions/","excerpt":"比赛地址分别为： 中秋节欢乐赛DIV1 中秋节欢乐赛DIV2","text":"比赛地址分别为： 中秋节欢乐赛DIV1 中秋节欢乐赛DIV2 所有比赛标程、数据都放置在了Github DIV1 作业计数 小凡一门学课的作业不做怒气总值增加bbb，那么aaa门作业不做怒气值即为a×ba\\times ba×b，答案为对mmm取膜的结果。 数据范围为1≤a,b,m≤10181\\leq a,b,m\\leq 10^{18}1≤a,b,m≤1018，此时你发现a×ba\\times ba×b会直接炸int。所以需要一些玄学的优化。 Ps：很抱歉，这题没给部分分。 方法一 使用自带高精度的python解决问题 1234a=int(input())b=int(input())m=int(input())print(a*b%m) 方法二 使用高精度的乘法和魔法 在这里推荐各位到yali_hzy的博客看看。我就不写了。。 高精取膜的方法为： a−b×⌊ab⌋\\begin{aligned} a-b\\times \\lfloor\\frac{a}{b}\\rfloor \\end{aligned} a−b×⌊ba​⌋​ 方法三 用快速乘的方法。 原理类似于卡速米。 12345678910#define ll long longll mul(ll a,ll b,ll m) &#123; ll ans=0; while(b) &#123; if(b&amp;1) b=(b+a)%m; a=(a+a)%m; b&gt;&gt;=1; &#125; return ans;&#125; 复杂度为Θ(log⁡b)\\Theta(\\log b)Θ(logb) 月饼采购 这可以算是一个非常经典的题目了，紫书、蓝书上都有。 和作业计数类似的，膜术可以这么算a−b×⌊ab⌋a-b\\times \\lfloor\\frac{a}{b}\\rfloora−b×⌊ba​⌋ 那么就可以得到以下推导 ans=∑i=1nk−i×⌊ab⌋=n×k−∑i=1ni×⌊ki⌋\\begin{aligned} ans&amp;=\\sum^{n}_{i=1}k-i\\times\\lfloor\\frac{a}{b}\\rfloor\\\\ &amp;=n\\times k-\\sum^{n}_{i=1}i\\times\\lfloor\\frac{k}{i}\\rfloor \\end{aligned} ans​=i=1∑n​k−i×⌊ba​⌋=n×k−i=1∑n​i×⌊ik​⌋​ 然后可以从⌊ki⌋\\lfloor\\frac{k}{i}\\rfloor⌊ik​⌋出发，得到答案。 复杂度为Θk\\Theta{\\sqrt{k}}Θk​。 分配月饼 Cnm=n!m!(n−m)!=∏i=n−mn∏i=1m\\begin{aligned} C^m_n&amp;=\\frac{n!}{m!(n-m)!}\\\\ &amp;=\\frac{\\prod^{n}_{i=n-m}}{\\prod^{m}_{i=1}} \\end{aligned} Cnm​​=m!(n−m)!n!​=∏i=1m​∏i=n−mn​​​ 得到了以上的结论后即可做到在Θ(2×m)\\Theta(2\\times m)Θ(2×m)，的复杂度内求解。 而原题的n≤2×105n\\leq2\\times10^5n≤2×105，因此可以通过。 值得一提的是，在做除法意义下的膜法时，需要用到逆元。 DIV2 Ps：早知道就用OI赛制了，这样Imakf就不能AK了。 价格统计 直接依照题意模拟即可，把细节把握好。 月光计算 这是一道非常简单的数学题。 nnn行，n−1n-1n−1列的星星加上一行不少于1的星星肯定是要大于(n−1)2(n-1)^2(n−1)2颗星星的。 {y1=n(n−1)+1=n2−n+1y2=(n−1)2=n2−2n+1\\left\\{ \\begin{aligned} y1&amp;=n(n-1)+1=n^2-n+1\\\\ y2&amp;=(n-1)^2=n^2-2n+1\\\\ \\end{aligned} \\right. {y1y2​=n(n−1)+1=n2−n+1=(n−1)2=n2−2n+1​ 所以可以得出y1&gt;y2y1&gt;y2y1&gt;y2。答案即为n2n^2n2，不过记得开long long 月饼管理 提示中的数据结构是前缀和。 您可以参考我的这篇文章。 这里就不多累赘了。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"树状数组基础","slug":"basic-bit","date":"2018-09-10T23:00:42.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/basic-bit/","link":"","permalink":"https://www.micdz.cn/article/basic-bit/","excerpt":"树状数组是一个非常高效的支持区间修改单点查询的数据结构。","text":"树状数组是一个非常高效的支持区间修改单点查询的数据结构。 引入 线段树和树状数组，是两个十分相似的数据结构。他们能使对一个区间的数修改以及查询的速度提升许多。两个结构本质相同，各有优缺点，今天我们来从单点修改，单点查询，区间修改，区间查询进行了解。 内容及存储方式 树的形式 AAA数组是原数组，CCC数组是树状数组。 CCC树状数组中的每一个元素都是其所有叶节点的总和。特别的，叶子结点就是对应的原数组。 数的规律 1234c1=a1;c2=a1+a2;c3=a3;c4=a1+a2+a3+a4; 根据树状数组的定义，可以得到如上。没有必要纠结为什么是这样，只需要知道这样有什么用，因为这个定义也是人为定义出来的。 那么，这里的规律究竟是怎么样的？ 将上述表格中的下标转化为二进制后即可发现规律。 1234c0001=a0001c0010=a0001+a0010c0011=a0011c0100=a0001+a0010+a0011+a0100 从左向右数，CCC数组下标有nnn个0就有2n2^n2n个元素。 核心代码 单点更新 123456void change(int x,int v) &#123; while(x&lt;=n) &#123; t[x]+=v; x+=x&amp;(-x); &#125;&#125; 利用此操作，将第xxx个元素增加v。 前缀查询 12345678int ask(int x) &#123; int ans=0; while(x) &#123; ans+=t[x]; x-=x&amp;(-x); &#125; return ans;&#125; 得到的结果是前xxx个元素的和。 区间修改 差分存储 我们将原数组的差分数组插入到树状数组中。 例如 [2,6,9,1,3,4][2,6,9,1,3,4][2,6,9,1,3,4] 的差分数组为 [2,4,3,−8,2,1][2,4,3,-8,2,1][2,4,3,−8,2,1] ，可以看出，差分数组 bi=ai−ai−1b_i=a_i-a_{i-1}bi​=ai​−ai−1​ 。 这样的好处是查找某个元素可以直接树状数组求前缀和。 差分修改 如果要将从 [l,r][l,r][l,r] 的所有元素加上 xxx ，只需要将 bl+xb_l+xbl​+x 和 br+1−xb_{r+1}-xbr+1​−x 。在求前缀和时，只会对 [l,r][l,r][l,r] 有影响。而对后面和前面的数没有影响。 为了节省空间，可以如下进行插入： 12345for(int i=1; i&lt;=n; i++) &#123; a=read(); change(i,a-b); b=a;&#125; 完整代码 LG3368 【模板】树状数组 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define MAXN 500000+10#define ll long longint read() &#123; int x=0,f=1; char ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int n,m;int a,b,t[MAXN];void change(int x,int v) &#123; while(x&lt;=n) &#123; t[x]+=v; x+=x&amp;(-x); &#125;&#125;int ask(int x) &#123; int ans=0; while(x) &#123; ans+=t[x]; x-=x&amp;(-x); &#125; return ans;&#125;int main() &#123; n=read(),m=read(); for(int i=1; i&lt;=n; i++) &#123; a=read(); change(i,a-b); b=a; &#125; for(int i=1; i&lt;=m; i++) &#123; int pd=read(); if(pd==1) &#123; int x=read(),y=read(),k=read(); change(x,k); change(y+1,-k); &#125; else &#123; int x=read(); printf(&quot;%d\\n&quot;,ask(x)); &#125; &#125;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"苹果系统更新后无法使用gcc编译器解决方案","slug":"gcc-compiler-problem","date":"2018-08-20T23:10:36.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/gcc-compiler-problem/","link":"","permalink":"https://www.micdz.cn/article/gcc-compiler-problem/","excerpt":"谨以此篇文章，献给一整个晚上的艰难探索。","text":"谨以此篇文章，献给一整个晚上的艰难探索。 今晚我安装了macOS Mojave操作系统，本是一件非常激动的事情，但是突然却变得十分悲伤。 我的g++编译器崩溃了！ 经过了一晚上的艰难探索。为后来者提供解决方案。 出现这种情况的原因是，苹果公司会在系统更新的时候自动清除usr目录下的一些没有用的东西。其中就有我们的include文件。当我们使用g++进行编译的时候，会从/usr/include/目录寻找头文件，而因为系统更新会发现找不到一堆头文件。 此时你需要到你的别的电脑上把头文件们拷过来。（或许有更好的方法）","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://www.micdz.cn/categories/Solutions/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"【LG2893】修路 题解","slug":"LG2893-solution","date":"2018-08-20T22:22:56.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/LG2893-solution/","link":"","permalink":"https://www.micdz.cn/article/LG2893-solution/","excerpt":"在最优解的排行榜中看到了一种神奇的方法。 声明：此题解的思路来源于洛谷代码公开计划。","text":"在最优解的排行榜中看到了一种神奇的方法。 声明：此题解的思路来源于洛谷代码公开计划。 核心思路 这是一个DP的裸题，然而。。总有一些神人用神奇的方法解决了问题。 首先建一个大根堆和一个小根堆，将每一个的路面高度push进去，这里可以用STL的优先队列。 用大根堆模拟递增的情况，小根堆模拟递减的情况。 接下来利用一种类似于贪心的方法解决这道题。 因为这里有一个结论：修改后的道路高度在原来的道路的高度中。 那么面对每一次插入的高度，如果它的高度要比小根堆中已插入的最小的高度要大的话，那么就可以把它休整到和最小的同样高度。同理，反之是相反的操作。 这样尽管不能在每次操作的时候确定当前路段的花费，但是总和确是确定的。 给张图理解下： 完整代码 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;priority_queue&lt;int&gt; p;int ans1,ans2;int main()&#123; int n=read(); for(int i=1; i&lt;=n; i++) &#123; cin&gt;&gt;x; p.push(x); q.push(x); if(q.top()&lt;x) &#123; ans1+=abs(q.top()-x);//这里要加一个abs q.pop(); q.push(x); &#125; if(p.top()&gt;x) &#123; ans2+=p.top()-x; p.pop(); p.push(x); &#125; &#125; printf(&quot;%d\\n&quot;,min(ans1,ans2)); return 0;&#125; 欢迎批评指正！","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.micdz.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","permalink":"https://www.micdz.cn/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"Linux配置ssr客户端","slug":"Linux-ssr","date":"2018-08-19T11:27:43.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/Linux-ssr/","link":"","permalink":"https://www.micdz.cn/article/Linux-ssr/","excerpt":"ShadowsocksR A fast tunnel proxy that helps you bypass firewalls.","text":"ShadowsocksR A fast tunnel proxy that helps you bypass firewalls. Server Install Debian / Ubuntu: apt-get install git git clone https://github.com/shadowsocksr/shadowsocksr.git CentOS: yum install git git clone https://github.com/shadowsocksr/shadowsocksr.git Windows: git clone https://github.com/shadowsocksr/shadowsocksr.git Usage for single user on linux platform If you clone it into “~/shadowsocksr” move to “~/shadowsocksr”, then run: bash initcfg.sh move to “~/shadowsocksr/shadowsocks”, then run: python server.py -p 443 -k password -m aes-128-cfb -O auth_aes128_md5 -o tls1.2_ticket_auth_compatible Check all the options via -h. You can also use a configuration file instead (recommend), move to “~/shadowsocksr” and edit the file “user-config.json”, then move to “~/shadowsocksr/shadowsocks” again, just run: python server.py To run in the background: ./logrun.sh To stop: ./stop.sh To monitor the log: ./tail.sh","categories":[{"name":"Dev","slug":"Dev","permalink":"https://www.micdz.cn/categories/Dev/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"黑科技","slug":"黑科技","permalink":"https://www.micdz.cn/tags/%E9%BB%91%E7%A7%91%E6%8A%80/"}]},{"title":"【LG1784】 解数独 题解","slug":"LG1784-solution","date":"2018-08-16T22:49:58.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/LG1784-solution/","link":"","permalink":"https://www.micdz.cn/article/LG1784-solution/","excerpt":"一道即水的搜索题，不过还是有需要留意的地方，题目链接here。","text":"一道即水的搜索题，不过还是有需要留意的地方，题目链接here。 核心思路 dfs搜索 由左上至右下一次搜索，当找到答案或到达最右下角时结束。 值得一提的是，如何确定每一个格子所在的9宫格中的哪一个。 我用了一个mark函数进行计算。 1234int mark(int x,int y)&#123; int u=ceil(x*1.0/3),v=ceil(y*1.0/3); return (u-1)*3+v;&#125; 整体的思维难度不大。但是我在题解中看到一种神奇的写法。 1234567int mark(int x,int y)&#123; if(y&lt;=3) if(x&lt;=3) return 1; else if(x&lt;=6) return 2; else return 3; else if(y&lt;=6) if(x&lt;=3) return 4; else if(x&lt;=6) return 5; else return 6; else&#123; if(x&lt;=3) return 7; else if(x&lt;=6) return 8; else return 9; &#125;&#125; 剪枝 并没有什么值得剪枝的，复杂度其实完全复杂要求。唯一要做到的一点是，不能算重。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 10+1#define INF 0x3f3f3f#define file(a) freopen(&quot;j&quot;a&quot;.in&quot;,&quot;r&quot;,stdin),freopen(&quot;j&quot;a&quot;.ans&quot;,&quot;w&quot;,stdout)int read() &#123; int x=0,f=1; char ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int a[MAXN][MAXN],line[MAXN][MAXN],rall[MAXN][MAXN],box[MAXN][MAXN];int mark(int x,int y)&#123; int u=ceil(x*1.0/3),v=ceil(y*1.0/3); return (u-1)*3+v;&#125;bool found=0;void print() &#123; for(int i=1; i&lt;=9; i++)&#123; for(int j=1; j&lt;=9; j++) cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125;&#125;void dfs(int x,int y) &#123; if(x==10) y++,x=1; if(y==10&amp;&amp;x==1)&#123; print(); found=1; return ; &#125; if(a[x][y])&#123; dfs(x+1,y); return ; &#125; int q=mark(x,y); for(int i=1;i&lt;=9;i++)&#123; if(!line[x][i]&amp;&amp;!rall[y][i]&amp;&amp;!box[q][i])&#123; line[x][i]=1,rall[y][i]=1,box[q][i]=1,a[x][y]=i; dfs(x+1,y); line[x][i]=0,rall[y][i]=0,box[q][i]=0,a[x][y]=0; &#125; &#125;&#125;int main() &#123;//file(&quot;44&quot;); for(int i=1; i&lt;=9; i++) for(int j=1; j&lt;=9; j++) &#123; a[i][j]=read(); if(a[i][j]!=0) &#123; line[i][a[i][j]]=1; rall[j][a[i][j]]=1; box[mark(i,j)][a[i][j]]=1; &#125; &#125; dfs(1,1); return 0;&#125; 趣事 首先，你进入百度百科。然后仔细阅读。然后小心求证一下。 很有趣不是么？","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"dfs","slug":"dfs","permalink":"https://www.micdz.cn/tags/dfs/"}]},{"title":"【LG1004】方格取数 题解","slug":"LG1004-solution","date":"2018-08-01T08:27:59.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/LG1004-solution/","link":"","permalink":"https://www.micdz.cn/article/LG1004-solution/","excerpt":"这是一道四维DP的模版题，思维难度也不大，题目链接here","text":"这是一道四维DP的模版题，思维难度也不大，题目链接here 核心思路 定义dp[i][j][k][l]dp[i][j][k][l]dp[i][j][k][l]为第一次走到(i,j)(i,j)(i,j)第二次走到(k,l)(k,l)(k,l)的最优方案，a[i][j]a[i][j]a[i][j]为放在(i,j)(i,j)(i,j)处的数字。 由于每一步只能从i−1i-1i−1、j−1j-1j−1、k−1k-1k−1、l−1l-1l−1转移 状态转移方程就很好推出了： dp[i][j][k][l]=max⁡(dp[i−1][j][k−1][l],max(dp[i][j−1][k−1][l],dp[i][j−1][k][l−1],dp[i−1][j][k][l−1])++a[i][j]+a[k][l]dp[i][j][k][l]=\\max(dp[i-1][j][k-1][l],max(dp[i][j-1][k-1][l],dp[i][j-1][k][l-1],dp[i-1][j][k][l-1])++a[i][j]+a[k][l]dp[i][j][k][l]=max(dp[i−1][j][k−1][l],max(dp[i][j−1][k−1][l],dp[i][j−1][k][l−1],dp[i−1][j][k][l−1])++a[i][j]+a[k][l] 要尤其注意(i,j)(i,j)(i,j)和(k,l)(k,l)(k,l)相同的情况 完整代码 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 10+5int read() &#123; int x=0,f=1; char ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int dp[MAXN][MAXN][MAXN][MAXN],a[MAXN][MAXN];int main() &#123; int n=read(); while(1) &#123; int x,y,s; x=read(),y=read(),s=read(); if(x==0&amp;&amp;y==0&amp;&amp;s==0) break; a[x][y]=s; &#125; for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) for(int k=1; k&lt;=n; k++) for(int l=1; l&lt;=n; l++) &#123; dp[i][j][k][l]=max(dp[i-1][j][k-1][l],max(dp[i][j-1][k-1][l],max(dp[i][j-1][k][l-1],dp[i-1][j][k][l-1])))+a[i][j]+a[k][l]; if(i==k&amp;&amp;j==l) dp[i][j][k][l]-=a[i][j]; &#125; printf(&quot;%d&quot;,dp[n][n][n][n]);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.micdz.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"什么，你还在Mac上用Win！","slug":"macOS","date":"2018-07-29T14:30:09.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/macOS/","link":"","permalink":"https://www.micdz.cn/article/macOS/","excerpt":"注：本文适于使用macOS High Sierra的OIER 本文可能引起部分win用户的不良反应，请谨慎观看。","text":"注：本文适于使用macOS High Sierra的OIER 本文可能引起部分win用户的不良反应，请谨慎观看。 前言 苹果将在今年秋季发布macOS mojave的正式版本，到时候可能会写一篇与mojave有关文章。小D还不敢在新买的iMac上安装测试版系统。废话不多说，下面直接进入正题。 VIM的配置及使用 众所周知，在NOI linux这个膜改版的Ubuntu 14下，VIM可以说是效率最高，最方便的编辑器了。而macOS和Linux有着同一个祖先——Unix，自然他们俩的一些功能也就很相似了。 接下来小D将会介绍如何在macOS下把vim 配置得与NOI linux一样好用。 打开终端，终端的地址在应用程序-实用工具 打开终端后，分别输入如下指令 1$ cd ~ 1$ vim ~&#x2F;.vimrc 经过实测，并不要专门为vim新建一个文件夹 你会得到一个全新的文件，此时你就可以在这个文件中进行操作了，不需要担心，在这里的一切操作都是可以复原的。 你看到的可能与下面的有些许不同，是因为我已经把配色方案设置好了 这是我的配置文件内容 文档版 1234567891011121314151617181920212223242526272829303132set encoding&#x3D;utf-8set fileencoding&#x3D;utf-8set fileencodings&#x3D;ucs-bom,utf-8,chinesecolorscheme eveningsyntax enablesyntax onset shiftwidth&#x3D;4set nowrapset nu set mouse&#x3D;aset tabstop&#x3D;4set autoindentset rulerset cursorlineset nobackupcolor eveningmap &lt;F5&gt; &lt;Esc&gt;:w&lt;CR&gt; :call CompileRunGcc()&lt;CR&gt;imap &lt;F5&gt; &lt;Esc&gt;:w&lt;CR&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc() exec &quot;w&quot; if &amp;filetype &#x3D;&#x3D; &#39;c&#39; exec &#39;!g++ % -o %&lt; -lm -O2&#39; exec &#39;!time .&#x2F;%&lt;&#39; elseif &amp;filetype &#x3D;&#x3D; &#39;cpp&#39; exec &#39;!g++ % -o %&lt; -lm -O2&#39; exec &#39;!time .&#x2F;%&lt;&#39; elseif &amp;filetype &#x3D;&#x3D; &#39;sh&#39; :!time bash % endif endfunc map &lt;F6&gt; &lt;Esc&gt;:w&lt;CR&gt;map &lt;F7&gt; &lt;Esc&gt;:w&lt;CR&gt; :q&lt;CR&gt; 更多的配置方案可以参考：真实有效的Vim配置记录(macOS) 利用以上的配置可以实现： F5一键运行cpp、c的代码，您可以自己进行添加以实现py、pa的功能。 F6一键保存，F7一键保存并退出 当您配置好文件后，按键盘左上角的Esc然后依次输入:w和:q即可完成配置。 此时您可以到你的工作目录愉快地使用vim进行编程了。 将VIM的编译器变成g++ 当你按照上面的方法完成对VIM的配置后，愉快地进行编程，按下F5后的那一刻 woc，macOS竟然不支持bits？！此时心中有千万只***奔腾而过。不要慌张，下面是最轻松的解决方法。 macOS 自带的C编译器是Clang而这一个C编译器是不支持bits下的所有头文件的，即使你添加了源码也不支持（为此我专门打开了macOS的安全模式关闭了rootless）。 于是，我意识到，我可能需要安装一个g++，g++是肯定支持bits的。 于是就有了解决方案： 没有安装HomeBrew 的利用下面的代码安装 1ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot; 安装g++和gcc(4.9) 1brew install gcc@4.9 --with-all-languages 将编译指令改为g+±4.9 尝试执行下面的代码查看你的编译器 123456#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int main() &#123; cout &lt;&lt; __VERSION__ &lt;&lt; endl; return 0;&#125; 如果输出为g+±4.9，从此以后妈妈再也不用担心我忘记头文件。 在macOS上与外界交流 你只需要登陆你的iCloud账号就可以与任何拥有任意苹果设备的人（包括iPhone、iPod、Mac、iWatch、iPad）进行Facetime通话。如果你的手机在同一个局域网内并且登陆了同一个苹果账号即可进行普通的电话拨打给任意用户。 同样的，如果你登陆了iCloud即可给任意拥有苹果设备的人发送iMessage，如果你的手机在同一个局域网内并且登陆了同一个苹果账号即可发送普通的短信给任意用户。 不仅如此，还有更加厉害的联络方式——使用邮件 目前，已经支持了以上的所有邮件公司，足够满足我们的日常生活，但是！ 它还支持你的企业邮箱。 以qq企业邮箱为例 苹果的邮箱账户可以利用IMAP协议与你的企业邮箱进行连接，只需要输入您的地址和密码即可 接力使你的工作更加轻松 当你在iPad上打开luogu，看到一道非常好的题目，想要到电脑上实现它，非常轻松，只需要到duck的左下角，你会发现一个浏览器的图标左上角跟随了你的iPad图标。点开后甚至能够做到页面上的工作内容“接力”，例如luogu在线IDE。 更多方便的功能等你来探索 在macOS上有许多的高级的软件，例如Xcode、Final Cut……","categories":[{"name":"Others","slug":"Others","permalink":"https://www.micdz.cn/categories/Others/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"最近公共祖先(LCA)","slug":"lca","date":"2018-07-27T11:13:57.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/lca/","link":"","permalink":"https://www.micdz.cn/article/lca/","excerpt":"LCA最近公共祖先解决的是：对于有根树T的两个结点u、v，最近公共祖先LCA(T,u,v)表示一个结点x，满足x是u、v的祖先且x的深度尽可能大。","text":"LCA最近公共祖先解决的是：对于有根树T的两个结点u、v，最近公共祖先LCA(T,u,v)表示一个结点x，满足x是u、v的祖先且x的深度尽可能大。 通俗地讲就是下面的这个例子： 在上图中10和12的LCA就是3。 核心思路 模拟法 根据题意进行模拟。一步一步回向根节点递进，分别对到达的顶点标号，碰到的第一个两个都到达过的顶点即为两点的LCA了。 这样的做法非常自然，但是绝对不可能符合这一道题所要求的时间复杂度。 倍增法 仍旧是按照题意进行模拟，不同的是，这次不再一次一次向上找，这次以2的倍数从上向下找。 具体的操作步骤很简单，首先将两节点调到保证deep[X]&gt;=deep[Y]deep[X]&gt;=deep[Y]deep[X]&gt;=deep[Y]，如果这个时候两点是同一点则可以直接出答案，如果不行则将XXX从上向下跳。为什么要从上往下跳呢？ 通过上面的这个例子可以看出，如果从下向上的话，有可能跳到的那一个点不是最近公共祖先，而从上向下可以在找到后继续向下。 代码分解 p[i][j]p[i][j]p[i][j] 表示节点iii的2j2^j2j级祖先。 dfs求深度 1234567891011void dfs(int u,int fa) &#123;//u表示当前节点，fa表示它的父亲节点 d[u]=d[fa]+1;//深度比它的父亲要大1 p[u][0]=fa; for(int i=1; (1&lt;&lt;i)&lt;=d[u]; i++) p[u][i]=p[p[u][i-1]][i-1];//转移 for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(v!=fa)//v不是父亲节点 dfs(v,u);//从根节点出发进行dfs &#125;&#125; 上述的状态转移的含义是： uuu的2i2^i2i个祖先和uuu的2i−12^{i-1}2i−1个祖先的2i−12^{i-1}2i−1是同一个祖先 数学逻辑来讲就是2i=2×2×…×2×22^i=2\\times2\\times\\ldots\\times2\\times22i=2×2×…×2×2(共有i个2) 而2i−1=2×2×…×2×22^{i-1}=2\\times2\\times\\ldots \\times2\\times22i−1=2×2×…×2×2(共有i-1个2) 根据乘法分配律，得出2i−1+2i−1=2i2^{i-1}+2^{i-1}=2^i2i−1+2i−1=2i并且要满足2i≤d[u]2^i\\leq d[u]2i≤d[u]，其d[u]d[u]d[u]是该节点的深度。 所以上面的含义也就成立，可以得出每一个节点的任意的祖先（这里没有边权的概念）。 ST求LCA 1234567891011121314151617int lca(int a,int b) &#123; if(d[a]&gt;d[b]) swap(a,b); for(int i=20; i&gt;=0; i--) if(d[a]&lt;=d[b]-(1&lt;&lt;i)) b=p[b][i]; if(a==b) return a;//如果直接找到答案就可以输出了，此时一定是最近的解 for(int i=20; i&gt;=0; i--) &#123; if(p[a][i]==p[b][i]) continue;//得到第一个答案，但不确定是不是最近所以continue，继续 else &#123; a=p[a][i];//将a往下跳 b=p[b][i];//将b往下跳 &#125; &#125; return p[a][0];//经过20轮操作后即可得到最终答案，也等价于p[b][0]&#125; 这一步的操作也比较简单。首先必须确保aaa的深度要小于或等于bbb的深度。然后将深度大的bbb由上向下跳，可以说是从2202^{20}220开始逐步向下（这样可以有效降低代码难度而对程序运行几乎没有影响）。直到bbb刚刚跳到了aaa的上面。此时aaa与bbb的LCA就一定在aaa和bbb之间了。接下来的操作与刚才的非常相似，同样是进行20次“徘徊”，详细的内容见上方注释。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define MAXN 500000+10using namespace std;int head[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1],next[MAXN&lt;&lt;1],cnt=0;int n,m,s;void addedge(int u,int v) &#123; cnt++; to[cnt]=v; next[cnt]=head[u]; head[u]=cnt;&#125;int read() &#123;//快读略&#125;int d[MAXN],p[MAXN][21];void dfs(int u,int fa) &#123; d[u]=d[fa]+1; p[u][0]=fa; for(int i=1; (1&lt;&lt;i)&lt;=d[u]; i++) p[u][i]=p[p[u][i-1]][i-1]; for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(v!=fa) dfs(v,u); &#125;&#125;int lca(int a,int b) &#123; if(d[a]&gt;d[b]) swap(a,b); for(int i=20; i&gt;=0; i--) if(d[a]&lt;=d[b]-(1&lt;&lt;i)) b=p[b][i]; if(a==b) return a; for(int i=20; i&gt;=0; i--) &#123; if(p[a][i]==p[b][i]) continue; else &#123; a=p[a][i]; b=p[b][i]; &#125; &#125; return p[a][0];&#125;int main() &#123; memset(head,-1,sizeof(head)); n=read(); m=read(); s=read(); for(int i=1; i&lt;=n-1; i++) &#123; int x,y; x=read(),y=read(); addedge(x,y); addedge(y,x);//树是无向图 &#125; dfs(s,0); for(int i=1; i&lt;=m; i++) &#123; int a=read(),b=read(); printf(&quot;%d\\n&quot;,lca(a,b)); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"【NOIP2016】组合数问题 题解","slug":"NOIP2016d2t1-solution","date":"2018-07-26T14:32:19.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/NOIP2016d2t1-solution/","link":"","permalink":"https://www.micdz.cn/article/NOIP2016d2t1-solution/","excerpt":"NOIP2016中除了玩具谜题这道大水题之外，稍难一点的就是这道题了。 这是一篇原始文章，不保证内容的正确性","text":"NOIP2016中除了玩具谜题这道大水题之外，稍难一点的就是这道题了。 这是一篇原始文章，不保证内容的正确性 题目链接 核心思路 用杨辉三角存储下组合数的值，利用二维前缀和累加。代码实现非常简单，思维难度仅限于杨辉三角的部分。 不要被题面所迷惑了，都是骗人的，使用公式最多30分（代码完成度非常高且非常鲁棒）。 杨辉三角 123456 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1…… …… 上述就是最基础的杨辉三角。 你可以很轻松地发现第nnn行的第kkk个数字为组合数 Cn−1k−1C^{k-1}_{n-1}Cn−1k−1​ 具体的论证过程参照here 这样我们就可以Θ(2000×2000)\\Theta(2000\\times \\sqrt{2000})Θ(2000×2000​)把所有的组合数的值求出来了 二维前缀和 可以参照我的这篇文章。 这里的转移方程是 1s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]; s(i,j)表示题意中的n，m所对应的对数。 完整代码 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define MAXN 2000+10using namespace std;int read() &#123;//快读略&#125;int a[MAXN][MAXN],s[MAXN][MAXN];int main() &#123; int t=read(),k=read(); for(int i=0;i&lt;=2000;i++) &#123; a[i][i]=1; a[i][0]=1; &#125; for(int i=1; i&lt;=2000; i++) for(int j=1; j&lt;i; j++) a[i][j]=(a[i-1][j]+a[i-1][j-1])%k;//在计算的时候直接%k可以避免后面无效的重复计算 for(int i=1; i&lt;=2000; i++) for(int j=1; j&lt;=2000; j++) &#123; s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1];//前缀和口诀：上加左 减左上 加自己 if(a[i][j]==0&amp;&amp;j&lt;=i) s[i][j]++;//如果a[i][j]满足要求则++ &#125; for(int i=1; i&lt;=t ;i++) &#123; int n=read(),m=read(); printf(&quot;%d\\n&quot;,s[n][m]); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"如何尺规作出三等分点","slug":"make-three-equal-points","date":"2018-06-12T22:20:36.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/make-three-equal-points/","link":"","permalink":"https://www.micdz.cn/article/make-three-equal-points/","excerpt":"初一的时候，老师教我们画出了线段的中点，留下思考题思考如何作出三等分点至今未予以回答。 这是一篇原始文章，不保证内容的正确性","text":"初一的时候，老师教我们画出了线段的中点，留下思考题思考如何作出三等分点至今未予以回答。 这是一篇原始文章，不保证内容的正确性 中点 中点的作法很简单 如上图： ABABAB的中点是CCC证明过程非常简单 △ADE≅△BDE△ADC≅△BDC\\begin{aligned} \\triangle ADE \\cong \\triangle BDE\\\\ \\triangle ADC \\cong \\triangle BDC \\end{aligned} △ADE≅△BDE△ADC≅△BDC​ 三等分点 step1: 现给出一个线段ABABAB。 step2: 过AAA点作任意不与AB平行的直线。 step3: 以AAA为圆心任意半径作圆，交直线于CCC、DDD两点。 step4: 连接BBB、DDD，作其中点EEE（参照here）。 step5: 连接AE得到MMM，即为所求。","categories":[{"name":"Others","slug":"Others","permalink":"https://www.micdz.cn/categories/Others/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"几何","slug":"几何","permalink":"https://www.micdz.cn/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"【SDOI2009】SuperGCD 题解","slug":"SDOI2009-solution","date":"2018-06-08T22:58:43.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/SDOI2009-solution/","link":"","permalink":"https://www.micdz.cn/article/SDOI2009-solution/","excerpt":"最“快”的一道紫题。 这是一篇原始文章，不保证内容的正确性","text":"最“快”的一道紫题。 这是一篇原始文章，不保证内容的正确性 题目链接 辗转相除法并不会RE，python水过，好像py3自带了GCD函数（我不会写）。 1234567a=int(input()) b=int(input()) while b!=0: t=a a=b b=t%b print(a) 最慢的点164ms可以接受 noi不支持python，这是多么遗憾的一件事情。 中国还没有在OI圈普及，俄罗斯美国已经相当发达了。 就这么*掉了一道紫题，有点不好意思呢。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"高精度","slug":"高精度","permalink":"https://www.micdz.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"网络最大流","slug":"max-flow","date":"2018-06-04T22:39:25.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/max-flow/","link":"","permalink":"https://www.micdz.cn/article/max-flow/","excerpt":"半个月前学了网络最大流，，然后弃坑。。。 半个月后。。。","text":"半个月前学了网络最大流，，然后弃坑。。。 半个月后。。。 原谅我使用了一些来自互联网的图。 基础概念 通俗地来讲网络最大流问题就是就是求从工厂最多可以发出多少货物，不至于超过道路的容量限制，与上述通俗概念不同的是每一条道路是一次性的。也就是每一辆车通过每一条道路都需要将这条道路的容量减去车的载重直至容量小于0（好像是废话），因为如果不是这样就可以理解成第一辆车载着n通过了，第二辆车可以继续从这里载着n通过。 严格的定义就是：给定一个有向图，和两个点–源点A和汇点G，点之间有连边， 每条边有一个容量限制，网络流就是指由S点流到T点的一个可行流。 最大流就是指所有可行流里面最大的流。 上方给出的图就是从A出发到G最大的流。 求解 首先需要引入一个剩余的概念： 从上图来看，左边代表的是这条道路的容量，右边代表的是这条道路剩下的流量。 贪心 自然地可以想到贪心，但是贪心却是错误的。大致的思路就像是dijkstra算法，每一次找所连边中剩余最大的那一个，很容易就可以找到例子推翻。 例如在上面的这个经典的图中，我们找到了1-&gt;2-&gt;4-&gt;6 这条增广路，得到了汇点最大的流是2然而答案显然不是2。任可以1-&gt;3-&gt;4-&gt;2-&gt;5-&gt;6 最大是3。那么如何得到这个3呢？ DINIC DINIC的基本思路就是： 根据残量网络计算层次图。 在层次图中使用DFS进行增广直到不存在增广路 重复以上步骤直到无法增广 至于残量网络、层次图是什么，接下来用几个不同的思路来解决。 添加反向边 每插入一条边uuu到vvv的边权是www，我们考虑添加一条反向的边权为0的边，也就是从vvv到uuu边权是0的边。这样做的目的是使程序可以走“回头路”。考虑上方的图，每当从一个点流向另一个点时，将这条边的反向边加上流量值，如果到了下一个点仍保留往回走的方案。 具体类似于这样： 123456789//读边addedge(u,v,s);addedge(v,u,0);//内部dfs，这里的s指的是遍历到的边的剩余流量。e[i].w-=s; e[i^1].w+=s;/*^1的作用就是奇数-1偶数+1。相当于就是正向边-s，反向+s*/","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"},{"name":"网络流","slug":"网络流","permalink":"https://www.micdz.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"DINIC","slug":"DINIC","permalink":"https://www.micdz.cn/tags/DINIC/"}]},{"title":"SPFA深入解析","slug":"advanced-SPFA","date":"2018-05-28T22:19:30.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/advanced-SPFA/","link":"","permalink":"https://www.micdz.cn/article/advanced-SPFA/","excerpt":"SPFA是一种高效的单源最短路径算法。","text":"SPFA是一种高效的单源最短路径算法。 算法简述 读入每一条边的权值到邻接表 将最短路径数组初始化为INF 将起点加入队列 原点到原点路径设为0 从队列取出首元素 广度优先遍历出边 进行松弛操作，如可进行则将出边对应点加入队列 用一个数组表示i是否已入队 这是一个单源最短路径算法（废话） 正确性证明 其实只需证明SPFA的遍历过程是收敛的，可以看看段凡丁的介绍。 算法复杂度分析 经过长篇的分析与介绍，段凡丁在原文中给出了 T=Θ(mn⋅e)=Θ(k⋅e)\\begin{aligned} T=&amp;\\Theta(\\frac{m}{n}\\cdot e)\\\\ =&amp;\\Theta(k\\cdot e)\\\\ \\end{aligned} T==​Θ(nm​⋅e)Θ(k⋅e)​ 所以得出结论： T=Θ(e)\\begin{aligned} T=&amp;\\Theta(e) \\end{aligned} T=​Θ(e)​ 你不禁大叫：“假的吧！”。这里的 m,nm,nm,n 指的不是点数和边数， mmm 其实是外层while的循环次数。 没错，按照正常的推理逻辑的确可以得出这个结论。 但是 mn\\frac{m}{n}nm​ 完全可以很大，也就是 nnn 要远小于 mmm 时也就是一个稠密图时SPFA的复杂度竟然可以无限地趋近于 Θ(nm)\\Theta(nm)Θ(nm) 。这样就远远不如dijkstra算法了（实际上还有各种各样的常数）。 Ps：论文里的说法太不负责任了。 实现 下面以是热浪为例题的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 10000+10#define MAXM 65000+10#define INF 0x3f3f3fstruct edge&#123; long long to,next,v;&#125;e[MAXM*2];long long cnt,last[MAXN];;long long n,m,s,t;void add(long long u,long long v,long long w)&#123; cnt++; e[cnt].to=v; e[cnt].v=w; e[cnt].next=last[u]; last[u]=cnt;&#125;void spfa()&#123; long long inq[MAXN],d[MAXN]; queue&lt;long long&gt; q; memset(inq,0,sizeof(inq)); for(long long i=1;i&lt;=n;i++) d[i]=INF; d[s]=0;inq[s]=1; q.push(s); while(!q.empty())&#123; long long u=q.front(); q.pop(); inq[u]=0; for(long long i=last[u];i&gt;=0;i=e[i].next)&#123; long long v=e[i].to,w=e[i].v; if(d[v]&gt;d[u]+w)&#123; d[v]=d[u]+w; if(!inq[v])&#123; inq[v]=1; q.push(v); &#125; &#125; &#125; &#125; cout&lt;&lt;d[t]&lt;&lt;endl;&#125;long long read()&#123; long long x=0,f=1; char ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int main()&#123; memset(last,-1,sizeof(last)); n=read(),m=read(),s=read(),t=read(); for(long long i=1; i&lt;=m; i++)&#123; long long u=read(),v=read(),w=read(); add(u,v,w); add(v,u,w); &#125; spfa();&#125; References: Duan, Fanding (1994), “关于最短路径的SPFA快速算法”, 西南交通大学学报, 29 (2): 207–212 SPFA算法wiki","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"将Git本地仓库上传至github","slug":"localgit-to-github","date":"2018-05-25T20:28:22.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/localgit-to-github/","link":"","permalink":"https://www.micdz.cn/article/localgit-to-github/","excerpt":"近一段时间入手Git和GitHub，一直有许多疑惑。今天得以解决。更加深了对于Git的使用以及对GitHub的看法。 本文将会系统地介绍将Git本地仓库上传至github。","text":"近一段时间入手Git和GitHub，一直有许多疑惑。今天得以解决。更加深了对于Git的使用以及对GitHub的看法。 本文将会系统地介绍将Git本地仓库上传至github。 准备工作： 一个GitHub账户。 一个GitHub仓库。 与GitHub账户绑定好ssh密钥。具体操作here 操作步骤 接下来随便找到一个文件夹，右键git bash here。 将这个文件夹与你的仓库绑定 1$ git remote add origin git@github.com:youusername&#x2F;test.git 将仓库上的文件拉下来，否则会报错 1$ git pull origin master 记录下刚刚操作的文件 1$ git add . 提交到GitHub 1$ git push origin master 最后你就可以到你的GitHub仓库中查看代码了。","categories":[{"name":"Dev","slug":"Dev","permalink":"https://www.micdz.cn/categories/Dev/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"简单数论","slug":"basic-math","date":"2018-05-13T22:45:53.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/basic-math/","link":"","permalink":"https://www.micdz.cn/article/basic-math/","excerpt":"数论是学习OI的必经之路。","text":"数论是学习OI的必经之路。 Primarily Test Normal Sieve 对于每一个数，筛去所有倍数，因为它的倍数有它自己这个因子 时间复杂度： n∑i=11in\\sum\\limits_{i=1}\\frac{1}{i}ni=1∑​i1​ Sieve of Eratosthenes 埃拉托色尼筛选法，伪线性筛算法（ 与线性筛算法呈常数关系） 对于每一个质数，筛去所有它的倍数 一个显然的优化是 i−i2i-i^2i−i2 这一段的数是不用筛的 时间复杂度： n∑p≤n1p=O(nlog⁡log⁡n)n\\sum\\limits_{p\\le n}\\frac{1}{p}=O(n\\log\\log n)np≤n∑​p1​=O(nloglogn) Linear Sieve 对于每一个数，用小于等于它最小的质因子的所有质数筛 每一个数只会被它最小的质因子筛到一次 时间复杂度： O(n)O(n)O(n) Multiplicative Function 欧拉函数一种重要的积性函数 φ(n)φ(n)φ(n) 表小于等于 nnn 的数中与 nnn 互质的数的个数 计算方法: φ(n)=nΠp∣np−1p\\varphi(n)=n\\mathop\\Pi\\limits_{p|n}\\frac{p-1}{p}φ(n)=np∣nΠ​pp−1​ 本质：容斥原理，直接枚举质因数计算 GCD k|a 且k|b , k is a common factor of a and b We call the largest k Greatest Common Divisor of a and b 若 b=0b=0b=0 ，gcd(a,b)=agcd(a,b)=agcd(a,b)=a gcd(a,b)=gcd(a−b,b)gcd(a,b)=gcd(a-b,b)gcd(a,b)=gcd(a−b,b) gcd⁡(a,b)=gcd⁡(b%a,a)\\gcd(a,b)=\\gcd(b\\%a,a)gcd(a,b)=gcd(b%a,a) 辗转相除，时间复杂度O(log n) 52：36","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"【LG2085 最小函数值 题解","slug":"LG2085-solution","date":"2018-05-12T09:59:02.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/LG2085-solution/","link":"","permalink":"https://www.micdz.cn/article/LG2085-solution/","excerpt":"题目链接here 正解讲了啥我也不清楚，但是有一种神奇的解法。","text":"题目链接here 正解讲了啥我也不清楚，但是有一种神奇的解法。 核心思路 其中关键在于： 12345void work(int a,int b,int c)&#123; for(int i=1;i&lt;=sqrt(m)+1;i++)&#123; q.push(a*i*i+b*i+c); &#125;&#125; 在计算中只计算m\\sqrt mm​的范围。如果直接m的话只能勉强获得20分。 因为计算m的复杂度是Θ(nm)\\Theta(nm)Θ(nm)，显然会超时。 这可能是一种投机取巧的方式，如果数据强一点一定会被卡掉，因为当二次函数的对称轴大于了m\\sqrt mm​，最小值就一定不会在m\\sqrt mm​的范围内了（a&gt;0a&gt;0a&gt;0的情况），a&lt;0a&lt;0a&lt;0同样成立。 建议管理员还是可以强化一下数据，hack非正解。 完整代码 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;#define MAXN 200000+10#define INF 0x3f3f3fusing namespace std;int read()&#123; int x=0,f=1; char ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int a[MAXN],n,m;priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;void work(int a,int b,int c)&#123; for(int i=1;i&lt;=sqrt(m)+1;i++)&#123; q.push(a*i*i+b*i+c); &#125;&#125;int main()&#123; n=read(); m=read(); int a,b,c; for(int i=1;i&lt;=n;i++)&#123; a=read(),b=read(),c=read(); work(a,b,c); &#125; for(int i=1;i&lt;=m;i++)&#123; cout&lt;&lt;q.top()&lt;&lt;&quot; &quot;; q.pop(); &#125;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"堆","slug":"堆","permalink":"https://www.micdz.cn/tags/%E5%A0%86/"}]},{"title":"【HAOI2006】聪明的猴子 题解","slug":"HAOI2006-solution","date":"2018-05-05T16:52:38.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/HAOI2006-solution/","link":"","permalink":"https://www.micdz.cn/article/HAOI2006-solution/","excerpt":"题目链接here 题目不难，普及/提高-","text":"题目链接here 题目不难，普及/提高- 核心思路 找到最小生成树的。 记录下最小生成树的最大边。 比较每一只猴子的跳跃最远距离与最大边的关系，可以跳过则ans++。 易错点 看上去很简单，可以直接将最小生成树直接拿过来套模板，我就是这样做的，然而： 2AC，3WA，5RE。 我开始找问题，经历了大概两天的时间，我总结出了以下这些坑点，作为一个刚开始做图论题的蒟蒻容易错的一些坑点。 ​ 1. 套模板时忘记把n改为cnt，cnt指的是在图中的n个点与其它点构成的n×(n−1)2\\frac{n\\times (n-1)}{2}2n×(n−1)​条边。 ​ 2. 忘记将struct存下的边开大到n×(n−1)2\\frac{n\\times (n-1)}{2}2n×(n−1)​，在题目中也就是大约1000000。 ​ 3. f[]数组没有完全初始化。 代码 由于套模板，这里的代码非常丑陋。 简单的读入 1234int m=read();for(int i=1;i&lt;=m;i++)hd[i]=read();int n=read();for(int i=1;i&lt;=n;i++)x[i]=read(),y[i]=read(); 处理每一条边 1234567for(int i=1;i&lt;=n;i++)for(int j=i+1;j&lt;=n;j++)&#123; cnt++; a[cnt].u=i; a[cnt].v=j; a[cnt].s=dist(x[i],x[j],y[i],y[j]);&#125; 非常丑陋的核心代码 1234567891011121314151617sort(a+1,a+1+cnt,cmp);for(int i=1;i&lt;=MAXN;i++)f[i]=i;int ans=0,s=0;for(int i=1;i&lt;=cnt;i++)&#123; if(find(a[i].u)!=find(a[i].v))&#123; link(a[i].u,a[i].v); s++; if(a[i].s&gt;maxx)maxx=a[i].s; if(s==n-1)&#123;//找到答案了 int shu=0; //cout&lt;&lt;maxx; for(int i=1;i&lt;=m;i++)if(hd[i]&gt;=maxx)shu++;//计数 cout&lt;&lt;shu&lt;&lt;endl; return 0; &#125; &#125;&#125; 完整代码here","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"kruskal","slug":"kruskal","permalink":"https://www.micdz.cn/tags/kruskal/"}]},{"title":"前向星存图","slug":"qian-xiang-xing","date":"2018-05-03T22:13:56.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/qian-xiang-xing/","link":"","permalink":"https://www.micdz.cn/article/qian-xiang-xing/","excerpt":"为什么要用前向星存图？ 前向星可以很方便地读取点的出边，在某些图论算法（如SPFA）中可以做到很低的复杂度 FlyuZ：邻接表是用链表实现的，可以动态的增加边， 而前向星是用结构体数组实现的，是静态的，需要一开始知道数据范围，开好数组大小。 相比之下，邻接表灵活，但链式前向星好写。 这里只介绍链式前向星。 这是一篇原始文章，不保证内容的正确性","text":"为什么要用前向星存图？ 前向星可以很方便地读取点的出边，在某些图论算法（如SPFA）中可以做到很低的复杂度 FlyuZ：邻接表是用链表实现的，可以动态的增加边， 而前向星是用结构体数组实现的，是静态的，需要一开始知道数据范围，开好数组大小。 相比之下，邻接表灵活，但链式前向星好写。 这里只介绍链式前向星。 这是一篇原始文章，不保证内容的正确性 准备工作 head[x]是点的头指针 next[i]是链表的下一个元素 to[i]是这一个点所到达的边，e[i].v是这条边的权值 建立边表 1int head[MAXN],to[MAXN],next[MAXN],weigh[MAXN]; 加边的方法 1234567void add(int u,int v,int w)&#123; cnt++;//cnt可以理解为当前加入这条边的编号 to[cnt]=v;//这条边指向了v，可以这么理解，所有邻接表中只有to会指向点的编号 next[cnt]=head[u];//将当前边的的下一条边指向u的头指针 head[u]=cnt;//更新u的头指针 weigh[cnt]=w;//记录边权&#125; 原理 cnt记录的是当前点的序号，后面所有的操作都是在cnt内的。 将cnt的边的终点指向v。 将下一个元素连到起点u的头指针并更新u的头指针。 最后记录边权，这一步可有可无。 遍历的方法 123for(int i=head[now]; i!=0; i=next[i]) &#123; //Do something&#125; 从now的头元素开始沿着链表遍历全图。 效率对比 方式 查询（出边） 插入 邻接矩阵 Θ(n)\\Theta(n)Θ(n) Θ(1)\\Theta(1)Θ(1) 前向星 Θ(k)\\Theta(k)Θ(k) Θ(3)\\Theta(3)Θ(3) 注：上图中的k指的是所连出边，n是指点的个数 也就是说，如果在一个完全图（任何一点与所有点都有连边）中，邻接表与邻接矩阵几乎是一样的。 代码提交 GYOJ提供了模板数据，具体参照here Update 2018.","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://www.micdz.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"【SCOI2005】繁忙的都市 题解","slug":"SCOI2005-solution","date":"2018-05-01T17:08:47.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/SCOI2005-solution/","link":"","permalink":"https://www.micdz.cn/article/SCOI2005-solution/","excerpt":"题目链接 这道题其实可以再水一点。 一道裸的最小生成树。 这是一篇原始文章，不保证内容的正确性","text":"题目链接 这道题其实可以再水一点。 一道裸的最小生成树。 这是一篇原始文章，不保证内容的正确性 核心思路 问题一就是输出n−1n-1n−1就OK了。 问题二只要一个maxx存下最大边。 为什么？here 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 200000+10#define INF 0x3f3f3fint f[MAXN];struct point&#123; int u,v,s;&#125;a[MAXN];int read()&#123; int f=1,x=0; char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int find(int x)&#123; if(f[x]==x)return f[x]; return f[x]=find(f[x]);&#125;int link(int x,int y)&#123; f[find(x)]=find(y);&#125;bool cmp(point a,point b)&#123; return a.s&lt;b.s;&#125;int main()&#123; int n=read(),m=read(); for(int i=1;i&lt;=m;i++) a[i].u=read(),a[i].v=read(),a[i].s=read(); sort(a+1,a+1+m,cmp); for(int i=1;i&lt;=m;i++)f[i]=i; int ans=0,s=0,maxx=-INF; for(int i=1;i&lt;=m;i++)&#123; if(find(a[i].u)!=find(a[i].v))&#123; link(a[i].u,a[i].v),ans+=a[i].s; s++; if(a[i].s&gt;maxx)maxx=a[i].s; if(s==n-1)&#123; cout&lt;&lt;n-1&lt;&lt;&quot; &quot;&lt;&lt;maxx; return 0; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"kruskal","slug":"kruskal","permalink":"https://www.micdz.cn/tags/kruskal/"}]},{"title":"最小生成树","slug":"mst","date":"2018-04-28T23:53:41.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/mst/","link":"","permalink":"https://www.micdz.cn/article/mst/","excerpt":"最小生成树的主要思路是贪心，用到了并查集的知识。","text":"最小生成树的主要思路是贪心，用到了并查集的知识。 定义 什么是最小生成树？ 给定一个图G&lt;V,E&gt;G&lt;V,E&gt;G&lt;V,E&gt;，G′&lt;v,e&gt;G&#x27;&lt;v,e&gt;G′&lt;v,e&gt;的v∈V,e∈Ev\\in V,e\\in Ev∈V,e∈E，且是一棵树时就可称G′G&#x27;G′是GGG的生成树。 最小生成树的定义就更清晰了。 即在GGG所有的生成树中，边权之和最小的一棵 题目链接 考虑用Kruskal算法，尽管离线但是效率感人。 看上去很麻烦？其实不然，只是简单的贪心罢了。 核心思路 1234将所有的点按照边权从小到大排列。找到最小的一条，如果首尾不在同一子树中则相连。如果在则舍弃。当连完n-1条边则可输出答案。 代码 代码并不难理解： 并查集部分 1234567int find(int x)&#123; if(f[x]==x)return f[x]; return f[x]=find(f[x]);&#125;int link(int x,int y)&#123; f[find(x)]=find(y);&#125; 用point存边，用cmp作排序规则 1234567struct point&#123; int u,v,s;&#125;a[MAXN];bool cmp(point a,point b)&#123; return a.s&lt;b.s;&#125; 读入的方式很简单 123int n=read(),m=read();for(int i=1;i&lt;=m;i++) a[i].u=read(),a[i].v=read(),a[i].s=read(); 就代表着a[i].u到a[i].v有一条边权为a[i].s的边。 核心代码 12345678910111213sort(a+1,a+1+m,cmp);//将边排序for(int i=1;i&lt;=m;i++)f[i]=i;//并查集初始化ans=0,s=0;//ans存答案，s存步骤for(int i=1;i&lt;=m;i++)&#123; if(find(a[i].u)!=find(a[i].v))&#123;//如果不在同一子树 link(a[i].u,a[i].v),ans+=a[i].s;//连接在一起，将ans更新 s++;//将s更新 if(s==n-1)&#123;//有了n-1条边 cout&lt;&lt;ans;//直接输出答案 return 0;//结束 &#125; &#125;&#125; 完整代码here 最小生成树不难理解，接下来还会有次小生成树等待学习。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"贪心","slug":"贪心","permalink":"https://www.micdz.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"kruskal","slug":"kruskal","permalink":"https://www.micdz.cn/tags/kruskal/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"【NOIP2017】奶酪 题解","slug":"NOIP2017d2t1-solution","date":"2018-04-26T22:17:05.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/NOIP2017d2t1-solution/","link":"","permalink":"https://www.micdz.cn/article/NOIP2017d2t1-solution/","excerpt":"","text":"Day2T1，普及/提高- 题目链接 这是一篇原始文章，不保证内容的正确性 核心思路 用一个结构体point封装点。 从1到n找到所有的与下底面相连的洞，即abs(a[i].z)&lt;=r。 从它开始dfs一步一步向与它所连的洞dist(a[i],a[x])&gt;2*r搜索。 如果到达一个洞可以到达上表面，即a[x].z+r&gt;=h，就找到答案了。 如果全部遍历了一遍都还没找到就可以确定不能到达了。 坐标距离公式，记得要double。 123double dist(point a,point b)&#123; return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2)+pow(a.z-b.z,2));&#125; 一个没有任何技术含量的dfs。 1234567891011void dfs(long long x)&#123; if(arr||x&gt;n)return; //cout&lt;&lt;&quot;in:&quot;&lt;&lt;x&lt;&lt;endl; if(a[x].z+r&gt;=h)&#123;arr=1;return;&#125; for(long long i=1;i&lt;=n;i++)&#123; if(have[i]||dist(a[i],a[x])&gt;2*r)continue; have[i]=1; dfs(i); //have[i]=0;千万千万不要回溯，每一个点遍历一次就好了，回溯百分百超时 &#125;&#125; 主函数。 12345678910111213141516171819202122232425int main()&#123; double H=read(); for(double i=1;i&lt;=H;i++)&#123; arr=0;//arr表示到或没到 s=0; n=read(),h=read(),r=read(); for(int i=1;i&lt;=n;i++)have[i]=0; for(long long i=1;i&lt;=n;i++)&#123; a[i].x=read(); a[i].y=read(); a[i].z=read(); &#125;//读入 for(long long i=1;i&lt;=n;i++) if(abs(a[i].z)&lt;=r)&#123; have[i]=1; dfs(i);//如果与下表面联通就dfs for(int i=1;i&lt;=n;i++)have[i]=0;//初始化 &#125; if(arr)cout&lt;&lt;&quot;Yes \\n&quot;; else cout&lt;&lt;&quot;No \\n&quot;;//不要再犯类似错误 &#125; &#125; 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define MAXN 1000+10#define MAXM 10000+10using namespace std;double read()&#123; double x=0,f=1; char ch=getchar(); while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;//丑陋一点不要介意struct point&#123; double x,y,z;&#125;a[MAXN];double dist(point a,point b)&#123; return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2)+pow(a.z-b.z,2));&#125;bool have[MAXM],arr;long long n,h,r;int s=0;void dfs(long long x)&#123; if(arr||x&gt;n)return; //cout&lt;&lt;&quot;in:&quot;&lt;&lt;x&lt;&lt;endl; if(a[x].z+r&gt;=h)&#123;arr=1;return;&#125; for(long long i=1;i&lt;=n;i++)&#123; if(have[i]||dist(a[i],a[x])&gt;2*r)continue; have[i]=1; dfs(i); //have[i]=0; &#125;&#125;int main()&#123; double H=read(); for(double i=1;i&lt;=H;i++)&#123; arr=0; s=0; n=read(),h=read(),r=read(); for(int i=1;i&lt;=n;i++)have[i]=0; for(long long i=1;i&lt;=n;i++)&#123; a[i].x=read(); a[i].y=read(); a[i].z=read(); &#125; for(long long i=1;i&lt;=n;i++) if(abs(a[i].z)&lt;=r)&#123; have[i]=1; dfs(i); for(int i=1;i&lt;=n;i++)have[i]=0; &#125; if(arr)cout&lt;&lt;&quot;Yes \\n&quot;; else cout&lt;&lt;&quot;No \\n&quot;; &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"},{"name":"题解","slug":"OI/题解","permalink":"https://www.micdz.cn/categories/OI/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://www.micdz.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"bfs","slug":"bfs","permalink":"https://www.micdz.cn/tags/bfs/"},{"name":"搜索","slug":"搜索","permalink":"https://www.micdz.cn/tags/%E6%90%9C%E7%B4%A2/"},{"name":"dfs","slug":"dfs","permalink":"https://www.micdz.cn/tags/dfs/"}]},{"title":"OI中的和式","slug":"sum-in-oi","date":"2018-04-22T18:23:11.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/sum-in-oi/","link":"","permalink":"https://www.micdz.cn/article/sum-in-oi/","excerpt":"一些基础的数学知识可以为我们提供非常好的思路，这里主要介绍的是∑\\sum∑求和符号。 这是一篇原始文章，不保证内容的正确性","text":"一些基础的数学知识可以为我们提供非常好的思路，这里主要介绍的是∑\\sum∑求和符号。 这是一篇原始文章，不保证内容的正确性 定义 求和是数学中常见又基本的操作, 我们需要为它找一个记号。假设现在有一个数列{a1,a2,...,sn}\\{ a_1,a_2,...,s_n\\}{a1​,a2​,...,sn​}我们需要有一种灵活又不复杂的记号, 来表示它们的和。 ∑i=1nai\\sum\\limits^n_{i=1}a_ii=1∑n​ai​ 表示数列数列{a}\\{a\\}{a}的和. 这是种记号非常类似for循环的前两个语句。(记号省略了第三个语句i++i++i++) 定律 就像所有运算符号一样，和式也有类似的规则： ∑k∈K(ak+bk)=∑k∈Kak+∑k∈Kbk\\sum\\limits_{k\\in K}(a_k+b_k)=\\sum\\limits_{k\\in K}a_k+\\sum\\limits_{k\\in K}b_kk∈K∑​(ak​+bk​)=k∈K∑​ak​+k∈K∑​bk​ 证明的方法是加法交换律。 ∑k∈Kcak=c∑k∈Kak\\sum\\limits_{k\\in K}ca_k=c\\sum\\limits_{k\\in K}a_kk∈K∑​cak​=ck∈K∑​ak​ 证明的方法是乘法分配律。 ∑i∈Aai∑j∈Bjj=∑i∈A∑j∈Baijj\\sum\\limits_{i\\in A}a_i\\sum\\limits_{j\\in B}j_j=\\sum\\limits_{i\\in A}\\sum\\limits_{j\\in B}a_ij_ji∈A∑​ai​j∈B∑​jj​=i∈A∑​j∈B∑​ai​jj​ 证明的方法是加法结合律，交换也是满足的。 问题 Description: 求Sn=∑i=0nxiS_n=\\sum\\limits^n_{i=0}x^iSn​=i=0∑n​xi 利用扰动法解此题： Sn+xn+1=x0+∑i=1n+1xi=x0+∑i=0nxi+1=x0+x∑i=0nxi=x0+xSn\\begin{aligned} S_n+x^{n+1}&amp;=x^0+\\sum\\limits^{n+1}_{i=1}x^i\\\\ &amp;=x^0+\\sum\\limits^n_{i=0}x^{i+1}\\\\ &amp;=x^0+x\\sum\\limits^n_{i=0}x^i\\\\ &amp;=x^0+xS_n\\\\ \\end{aligned} Sn​+xn+1​=x0+i=1∑n+1​xi=x0+i=0∑n​xi+1=x0+xi=0∑n​xi=x0+xSn​​ 解得 Sn=1−xn+11−x,x≠1=n+1,x=1\\begin{aligned} S_n&amp;=\\frac{1-x^{n+1}}{1-x},x\\neq 1\\\\ &amp;=n+1,x= 1 \\end{aligned} Sn​​=1−x1−xn+1​,x​=1=n+1,x=1​","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://www.micdz.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"简单的背包问题","slug":"backpack","date":"2018-04-18T22:48:46.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/backpack/","link":"","permalink":"https://www.micdz.cn/article/backpack/","excerpt":"背包问题是非常典型的动态规划问题。 包括01背包，完全背包，多重背包……","text":"背包问题是非常典型的动态规划问题。 包括01背包，完全背包，多重背包…… 01背包问题 有 nnn 件物品，最大载荷为 mmm 的背包， fi,jf_{i,j}fi,j​ 表示有前 iii 个物品，总量为 jjj 的情况的最优解 状态转移方程 fi+1,j={max⁡(fi,j,fi,j−wi+1+vi+1)wi+1≤jfi,jwi+1&gt;jf_{i+1,j} = \\left\\{ \\begin{aligned} \\max (f_{i,j},f_{i,j-w_i+1}+v_i+1)\\quad w_{i+1}\\leq j\\\\ {f_{i,j} \\quad w_{i+1}&gt; j}\\\\ \\end{aligned} \\right. fi+1,j​={max(fi,j​,fi,j−wi​+1​+vi​+1)wi+1​≤jfi,j​wi+1​&gt;j​ 代码 对应的代码就很简单了： 12345678for(int i=0;i&lt;=m;i++) f[0][i]=0;for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=m;j++)&#123; if(j&gt;=w[i]) f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i]); else f[i][j]=f[i-1][j]; &#125; 利用动态数组优化后的代码为： 12345678for(int i=0;i&lt;=m;i++) f[i]=0;for(int i=1;i&lt;=n;i++) for(int j=m;j&gt;=m;j--)&#123; if(j&gt;=w[i]) f[j]=max(f[j],f[j-w[i]]+v[i]); else f[j]=f[j]; &#125; 复杂度 时间复杂度 Θ(nm)\\Theta(nm)Θ(nm) ，空间线性。 完全背包问题 与01背包不同的是，每一个物品都有无数件 代码 12345678for(int i=0;i&lt;=m;i++) f[i]=0;for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(j&gt;=w[i]) f[j]=max(f[j],f[j-w[i]]+v[i]); else f[j]=f[j]; &#125; 内层循环正序即可实现。 复杂度 时间复杂度Θ(nm)\\Theta(nm)Θ(nm)，空间线性。","categories":[{"name":"OI","slug":"OI","permalink":"https://www.micdz.cn/categories/OI/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.micdz.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"随笔","slug":"随笔","permalink":"https://www.micdz.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","permalink":"https://www.micdz.cn/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"更新日志","slug":"update-data","date":"1997-01-01T00:00:00.000Z","updated":"2021-02-27T11:38:38.466Z","comments":true,"path":"article/update-data/","link":"","permalink":"https://www.micdz.cn/article/update-data/","excerpt":"这里是更新日志，记录一些blog小规模的更新操作。","text":"这里是更新日志，记录一些blog小规模的更新操作。 2018.4.23 将服务转向coding加速大陆地区访问速度。 采用了lk大佬的mathjex解决方案。 提交了coding pages 免弹窗审核。 2018.4.30 提交了百度收录sitemap。 重建了框架使访问更加迅速。 增加对移动设备的支持。 coding pages出现问题。 通过不懈的努力找到问题所在。 重新提交coding免弹窗许可。 2018.5.3 通过了coding审核。 增加了站长统计工具。 2018.5.6 将服务转向coding pages 动态部署。 2018.5.12 增强了网站安全性，关闭了所有贴图网图片。 重新使用coding pages 静态部署。 添加了Gitment评论功能。 2018.6.5 重要：全线停止使用www.douglas-zhou.cn。 Gitment因美观程度低而停止使用。 2018.7.7 经过反复的调查研究，决定启用Disqus。 2018.8.10 将公式的渲染方式更改为KaTeX\\KaTeXKATE​X，使访问更加迅速。 2018.8.21 发布MicDZ’s blog 2.0。 使用Valine评论。 因访问速度问题，停止使用网易云音乐浮窗。 2020.2.22 更新了主题文档（volantis-1.5） 2020.2.22 更新了标题规范 加入了Github修改功能","categories":[],"tags":[{"name":"更新日志","slug":"更新日志","permalink":"https://www.micdz.cn/tags/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"}]}]}